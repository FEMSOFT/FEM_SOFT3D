/*
 * =====================================================================================
 *
 *       Filename:  meshrefineconsistent.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  2014年09月20日 01时16分09秒
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Xu Fei (Fly), xufei@lsec.cc.ac.cn
 *        Company:  
 *
 * =====================================================================================
 */


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "Mesh3D.h"
#define NVERTS_PER_FACEE 3
#define NLINES_PER_FACEE 3
#define NVERTS_PER_VOLU 4
#define NLINES_PER_VOLU 6
#define NFACEES_PER_VOLU 4
#define NVERTS_PER_LINE 2

void
MeshRefineConsistent(MESH *mesh)
{
   int i,j,k;
   int num,NP,NF,NE,NV;
   //加密一次点线面体的个数变化
   int tmp_nverts = mesh->Num_Verts_Global+mesh->Num_Lines_Global;
   int tmp_nedges = mesh->Num_Lines_Global*2+mesh->Num_Faces_Global*3+mesh->Num_Volus_Global;
   int tmp_nfaces = mesh->Num_Faces_Global*4+mesh->Num_Volus_Global*8;
   int tmp_nvolus = mesh->Num_Volus_Global*8;

   NP= mesh->Num_Verts_Global;
   NE= mesh->Num_Lines_Global;
   NF= mesh->Num_Faces_Global;
   NV= mesh->Num_Volus_Global;
   int num_face[4];
   mesh->Verts=realloc(mesh->Verts,tmp_nverts*sizeof(VERT*));
   mesh->Lines=realloc(mesh->Lines,tmp_nedges*sizeof(LINE*));
   mesh->Faces=realloc(mesh->Faces,tmp_nfaces*sizeof(FACEE*));
   mesh->Volus=realloc(mesh->Volus,tmp_nvolus*sizeof(VOLU*));
 
   for(i=0;i<NE;++i)
  {
     num=i+NP;
     mesh->Verts[num]=malloc(sizeof(VERT));
  }
  for(i=0;i<tmp_nedges-NE;++i)
  {
     num=i+NE;
     mesh->Lines[num]=malloc(sizeof(LINE));
  }
  for(i=0;i<tmp_nfaces-NF;++i)
  {
     num=i+NF;
     mesh->Faces[num]=malloc(sizeof(FACEE));
  }
  for(i=0;i<tmp_nvolus-NV;++i)
  {
     num=i+NV;
     mesh->Volus[num]=malloc(sizeof(VOLU));
  }

   //更新点的信息,旧点编号不变，新点编号为 NP+边的编号。
  for(i=0;i<NE;++i)
  {
     num=i+NP;
     mesh->Verts[num]=malloc(sizeof(VERT));
     for(j=0;j<3;++j)
     {
	mesh->Verts[num]->Coord[j]=(mesh->Verts[mesh->Lines[i]->Verts[0]]->Coord[j]
	                           +mesh->Verts[mesh->Lines[i]->Verts[1]]->Coord[j])*1/2;
     }
     mesh->Verts[num]->Num_Lines_Owned = -1;
     mesh->Verts[num]->Lines_Owned = NULL;
     mesh->Verts[num]->Num_Faces_Owned = -1;
     mesh->Verts[num]->Faces_Owned = NULL;
     mesh->Verts[num]->Num_Volus_Owned = -1;
     mesh->Verts[num]->Volus_Owned = NULL;
  }
//更新单元上点的信息。 单元的编号顺序：0点对应的单元编号不变，其它七个排在ＮＶ后面。

  for(i=0;i<NV;++i)
  {
     //七个新单元
     mesh->Volus[NV+i*7+0]->Verts[0]=NP+mesh->Volus[i]->Lines[0];
     mesh->Volus[NV+i*7+0]->Verts[1]=mesh->Volus[i]->Verts[1];
     mesh->Volus[NV+i*7+0]->Verts[2]=NP+mesh->Volus[i]->Lines[3];
     mesh->Volus[NV+i*7+0]->Verts[3]=NP+mesh->Volus[i]->Lines[4];
     mesh->Volus[NV+i*7+0]->Ancestor=mesh->Volus[i]->Ancestor;
     mesh->Volus[NV+i*7+0]->Father=i;


     mesh->Volus[NV+i*7+1]->Verts[0]=NP+mesh->Volus[i]->Lines[1];
     mesh->Volus[NV+i*7+1]->Verts[1]=NP+mesh->Volus[i]->Lines[3];
     mesh->Volus[NV+i*7+1]->Verts[2]=mesh->Volus[i]->Verts[2];
     mesh->Volus[NV+i*7+1]->Verts[3]=NP+mesh->Volus[i]->Lines[5];
     mesh->Volus[NV+i*7+1]->Ancestor=mesh->Volus[i]->Ancestor;
     mesh->Volus[NV+i*7+1]->Father=i;

     mesh->Volus[NV+i*7+2]->Verts[0]=NP+mesh->Volus[i]->Lines[2];
     mesh->Volus[NV+i*7+2]->Verts[1]=NP+mesh->Volus[i]->Lines[4];
     mesh->Volus[NV+i*7+2]->Verts[2]=NP+mesh->Volus[i]->Lines[5];
     mesh->Volus[NV+i*7+2]->Verts[3]=mesh->Volus[i]->Verts[3];
     mesh->Volus[NV+i*7+2]->Ancestor=mesh->Volus[i]->Ancestor;
     mesh->Volus[NV+i*7+2]->Father=i;

     mesh->Volus[NV+i*7+3]->Verts[0]=NP+mesh->Volus[i]->Lines[0];
     mesh->Volus[NV+i*7+3]->Verts[1]=NP+mesh->Volus[i]->Lines[1];
     mesh->Volus[NV+i*7+3]->Verts[2]=NP+mesh->Volus[i]->Lines[2];
     mesh->Volus[NV+i*7+3]->Verts[3]=NP+mesh->Volus[i]->Lines[3];
     mesh->Volus[NV+i*7+3]->Ancestor=mesh->Volus[i]->Ancestor;
     mesh->Volus[NV+i*7+3]->Father=i;

     mesh->Volus[NV+i*7+4]->Verts[0]=NP+mesh->Volus[i]->Lines[0];
     mesh->Volus[NV+i*7+4]->Verts[1]=NP+mesh->Volus[i]->Lines[2];
     mesh->Volus[NV+i*7+4]->Verts[2]=NP+mesh->Volus[i]->Lines[4];
     mesh->Volus[NV+i*7+4]->Verts[3]=NP+mesh->Volus[i]->Lines[3];
     mesh->Volus[NV+i*7+4]->Ancestor=mesh->Volus[i]->Ancestor;
     mesh->Volus[NV+i*7+4]->Father=i;

     mesh->Volus[NV+i*7+5]->Verts[0]=NP+mesh->Volus[i]->Lines[5];
     mesh->Volus[NV+i*7+5]->Verts[1]=NP+mesh->Volus[i]->Lines[1];
     mesh->Volus[NV+i*7+5]->Verts[2]=NP+mesh->Volus[i]->Lines[3];
     mesh->Volus[NV+i*7+5]->Verts[3]=NP+mesh->Volus[i]->Lines[2];
     mesh->Volus[NV+i*7+5]->Ancestor=mesh->Volus[i]->Ancestor;
     mesh->Volus[NV+i*7+5]->Father=i;

     mesh->Volus[NV+i*7+6]->Verts[0]=NP+mesh->Volus[i]->Lines[5];
     mesh->Volus[NV+i*7+6]->Verts[1]=NP+mesh->Volus[i]->Lines[2];
     mesh->Volus[NV+i*7+6]->Verts[2]=NP+mesh->Volus[i]->Lines[3];
     mesh->Volus[NV+i*7+6]->Verts[3]=NP+mesh->Volus[i]->Lines[4];
     mesh->Volus[NV+i*7+6]->Ancestor=mesh->Volus[i]->Ancestor;
     mesh->Volus[NV+i*7+6]->Father=i;
   //旧单元
     mesh->Volus[i]->Verts[1]=mesh->Volus[mesh->Num_Volus_Global+i*7+0]->Verts[0];
     mesh->Volus[i]->Verts[2]=mesh->Volus[mesh->Num_Volus_Global+i*7+1]->Verts[0];
     mesh->Volus[i]->Verts[3]=mesh->Volus[mesh->Num_Volus_Global+i*7+2]->Verts[0];
     mesh->Volus[i]->Father=i;
  }
 //更新面包含的点。首先遍历单元，更新里面的八个面。
 for(i=0;i<NV;++i)
    {
      mesh->Faces[NF*4+i*8+0]->Verts[0]=NP+mesh->Volus[i]->Lines[0];
      mesh->Faces[NF*4+i*8+0]->Verts[1]=NP+mesh->Volus[i]->Lines[1];
      mesh->Faces[NF*4+i*8+0]->Verts[2]=NP+mesh->Volus[i]->Lines[2];

      mesh->Faces[NF*4+i*8+1]->Verts[0]=NP+mesh->Volus[i]->Lines[0];
      mesh->Faces[NF*4+i*8+1]->Verts[1]=NP+mesh->Volus[i]->Lines[4];
      mesh->Faces[NF*4+i*8+1]->Verts[2]=NP+mesh->Volus[i]->Lines[3];

      mesh->Faces[NF*4+i*8+2]->Verts[0]=NP+mesh->Volus[i]->Lines[5];
      mesh->Faces[NF*4+i*8+2]->Verts[1]=NP+mesh->Volus[i]->Lines[1];
      mesh->Faces[NF*4+i*8+2]->Verts[2]=NP+mesh->Volus[i]->Lines[3];

      mesh->Faces[NF*4+i*8+3]->Verts[0]=NP+mesh->Volus[i]->Lines[5];
      mesh->Faces[NF*4+i*8+3]->Verts[1]=NP+mesh->Volus[i]->Lines[4];
      mesh->Faces[NF*4+i*8+3]->Verts[2]=NP+mesh->Volus[i]->Lines[2];

      mesh->Faces[NF*4+i*8+4]->Verts[0]=NP+mesh->Volus[i]->Lines[1];
      mesh->Faces[NF*4+i*8+4]->Verts[1]=NP+mesh->Volus[i]->Lines[2];
      mesh->Faces[NF*4+i*8+4]->Verts[2]=NP+mesh->Volus[i]->Lines[3];

      mesh->Faces[NF*4+i*8+5]->Verts[0]=NP+mesh->Volus[i]->Lines[2];
      mesh->Faces[NF*4+i*8+5]->Verts[1]=NP+mesh->Volus[i]->Lines[4];
      mesh->Faces[NF*4+i*8+5]->Verts[2]=NP+mesh->Volus[i]->Lines[3];

      mesh->Faces[NF*4+i*8+6]->Verts[0]=NP+mesh->Volus[i]->Lines[0];
      mesh->Faces[NF*4+i*8+6]->Verts[1]=NP+mesh->Volus[i]->Lines[3];
      mesh->Faces[NF*4+i*8+6]->Verts[2]=NP+mesh->Volus[i]->Lines[2];

      mesh->Faces[NF*4+i*8+7]->Verts[0]=NP+mesh->Volus[i]->Lines[5];
      mesh->Faces[NF*4+i*8+7]->Verts[1]=NP+mesh->Volus[i]->Lines[2];
      mesh->Faces[NF*4+i*8+7]->Verts[2]=NP+mesh->Volus[i]->Lines[3];
    
      mesh->Faces[NF*4+i*8+0]->Num_Volus_Owned=-1;
      mesh->Faces[NF*4+i*8+0]->Volus_Owned=NULL;
     
      mesh->Faces[NF*4+i*8+1]->Num_Volus_Owned=-1;
      mesh->Faces[NF*4+i*8+1]->Volus_Owned=NULL;

      mesh->Faces[NF*4+i*8+2]->Num_Volus_Owned=-1;
      mesh->Faces[NF*4+i*8+2]->Volus_Owned=NULL;

      mesh->Faces[NF*4+i*8+3]->Num_Volus_Owned=-1;
      mesh->Faces[NF*4+i*8+3]->Volus_Owned=NULL;

      mesh->Faces[NF*4+i*8+4]->Num_Volus_Owned=-1;
      mesh->Faces[NF*4+i*8+4]->Volus_Owned=NULL;

      mesh->Faces[NF*4+i*8+5]->Num_Volus_Owned=-1;
      mesh->Faces[NF*4+i*8+5]->Volus_Owned=NULL;

      mesh->Faces[NF*4+i*8+6]->Num_Volus_Owned=-1;
      mesh->Faces[NF*4+i*8+6]->Volus_Owned=NULL;
     
      mesh->Faces[NF*4+i*8+7]->Num_Volus_Owned=-1;
      mesh->Faces[NF*4+i*8+7]->Volus_Owned=NULL;
    } 
//遍历面，更新外面的四个面包含的点的信息。
  for(i=0;i<NF;++i)
   {
     mesh->Faces[NF+i*3+0]->Verts[0]=mesh->Faces[i]->Verts[0];
     mesh->Faces[NF+i*3+0]->Verts[1]=NP+mesh->Faces[i]->Lines[2];
     mesh->Faces[NF+i*3+0]->Verts[2]=NP+mesh->Faces[i]->Lines[1];
   
     mesh->Faces[NF+i*3+1]->Verts[0]=NP+mesh->Faces[i]->Lines[2];
     mesh->Faces[NF+i*3+1]->Verts[1]=mesh->Faces[i]->Verts[1];
     mesh->Faces[NF+i*3+1]->Verts[2]=NP+mesh->Faces[i]->Lines[0];
   
     mesh->Faces[NF+i*3+2]->Verts[0]=NP+mesh->Faces[i]->Lines[1];
     mesh->Faces[NF+i*3+2]->Verts[1]=NP+mesh->Faces[i]->Lines[0];
     mesh->Faces[NF+i*3+2]->Verts[2]=mesh->Faces[i]->Verts[2];
   
     mesh->Faces[i]->Verts[0]=NP+mesh->Faces[i]->Lines[0];
     mesh->Faces[i]->Verts[1]=NP+mesh->Faces[i]->Lines[1];
     mesh->Faces[i]->Verts[2]=NP+mesh->Faces[i]->Lines[2];
      
     mesh->Faces[NF+i*3+0]->Volus_Owned=NULL;
     mesh->Faces[NF+i*3+0]->Num_Volus_Owned=-1;
 
     mesh->Faces[NF+i*3+1]->Volus_Owned=NULL;
     mesh->Faces[NF+i*3+1]->Num_Volus_Owned=-1;

     mesh->Faces[NF+i*3+2]->Volus_Owned=NULL;
     mesh->Faces[NF+i*3+2]->Num_Volus_Owned=-1;
   }
  
//更新单元里面的唯一一条新边的顶点的信息。
  for(i=0;i<NV;++i)
   {
     mesh->Lines[NE*2+NF*3+i]->Verts[0]=mesh->Volus[i]->Lines[2]+NP;    
     mesh->Lines[NE*2+NF*3+i]->Verts[1]=mesh->Volus[i]->Lines[3]+NP;    
    
     mesh->Lines[NE*2+NF*3+i]->Num_Faces_Owned=-1;
     mesh->Lines[NE*2+NF*3+i]->Faces_Owned=NULL;
     mesh->Lines[NE*2+NF*3+i]->Num_Volus_Owned=-1;
     mesh->Lines[NE*2+NF*3+i]->Volus_Owned=NULL;
   }
//更新面上的三条边的顶点信息。
  for(i=0;i<NF;++i)
   {
     mesh->Lines[NE*2+i*3+0]->Verts[0]=mesh->Faces[i]->Lines[1]+NP;
     mesh->Lines[NE*2+i*3+0]->Verts[1]=mesh->Faces[i]->Lines[2]+NP;

     mesh->Lines[NE*2+i*3+1]->Verts[0]=mesh->Faces[i]->Lines[0]+NP;
     mesh->Lines[NE*2+i*3+1]->Verts[1]=mesh->Faces[i]->Lines[2]+NP;

     mesh->Lines[NE*2+i*3+2]->Verts[0]=mesh->Faces[i]->Lines[0]+NP;
     mesh->Lines[NE*2+i*3+2]->Verts[1]=mesh->Faces[i]->Lines[1]+NP;
   
     mesh->Lines[NE*2+i*3+0]->Num_Faces_Owned=-1;
     mesh->Lines[NE*2+i*3+0]->Faces_Owned=NULL;
     mesh->Lines[NE*2+i*3+0]->Num_Volus_Owned=-1;
     mesh->Lines[NE*2+i*3+0]->Volus_Owned=NULL;
    
     mesh->Lines[NE*2+i*3+1]->Num_Faces_Owned=-1;
     mesh->Lines[NE*2+i*3+1]->Faces_Owned=NULL;
     mesh->Lines[NE*2+i*3+1]->Num_Volus_Owned=-1;
     mesh->Lines[NE*2+i*3+1]->Volus_Owned=NULL;
   
     mesh->Lines[NE*2+i*3+2]->Num_Faces_Owned=-1;
     mesh->Lines[NE*2+i*3+2]->Faces_Owned=NULL;
     mesh->Lines[NE*2+i*3+2]->Num_Volus_Owned=-1;
     mesh->Lines[NE*2+i*3+2]->Volus_Owned=NULL;
   }
//更新边上的新边点的信息。
  for(i=0;i<NE;++i)
  {
    mesh->Lines[NE+i]->Verts[0]=i+NP;
    mesh->Lines[NE+i]->Verts[1]=mesh->Lines[i]->Verts[1];
    mesh->Lines[i]->Verts[0]=mesh->Lines[i]->Verts[0];
    mesh->Lines[i]->Verts[1]=i+NP;
   
    mesh->Lines[NE+i]->Num_Faces_Owned=-1;
    mesh->Lines[NE+i]->Faces_Owned=NULL;
    mesh->Lines[NE+i]->Num_Volus_Owned=-1;
    mesh->Lines[NE+i]->Volus_Owned=NULL;
 }
//更新边的信息： 首先更新单元包含的边,以及面包含的边
  for(i=0;i<NV;++i)  
  {

    for(j=0;j<4;++j)
      num_face[j]=mesh->Volus[i]->Faces[j];
  
     /* 第一条边 */
   if(mesh->Lines[mesh->Volus[i]->Lines[0]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[1])
   {
    mesh->Volus[NV+i*7+0]->Lines[0]=mesh->Volus[i]->Lines[0];
    mesh->Volus[i]->Lines[0]=mesh->Volus[i]->Lines[0]+NE;
   }
   else
   {
    mesh->Volus[NV+i*7+0]->Lines[0]=mesh->Volus[i]->Lines[0]+NE;
    mesh->Volus[i]->Lines[0]=mesh->Volus[i]->Lines[0];
   }
   /* 第二条边 */
   if(mesh->Lines[mesh->Volus[i]->Lines[1]]->Verts[0]==mesh->Volus[NV+i*7+1]->Verts[2])
   {
    mesh->Volus[NV+i*7+1]->Lines[1]=mesh->Volus[i]->Lines[1];
    mesh->Volus[i]->Lines[1]=mesh->Volus[i]->Lines[1]+NE;
   }
   else
   {
    mesh->Volus[NV+i*7+1]->Lines[1]=mesh->Volus[i]->Lines[1]+NE;
    mesh->Volus[i]->Lines[1]=mesh->Volus[i]->Lines[1];
   }
   /*第三条边*/
   if(mesh->Lines[mesh->Volus[i]->Lines[2]]->Verts[0]==mesh->Volus[NV+i*7+2]->Verts[3])
   {
    mesh->Volus[NV+i*7+2]->Lines[2]=mesh->Volus[i]->Lines[2];
    mesh->Volus[i]->Lines[2]=mesh->Volus[i]->Lines[2]+NE;
   }
   else
   {
    mesh->Volus[NV+i*7+2]->Lines[2]=mesh->Volus[i]->Lines[2]+NE;
    mesh->Volus[i]->Lines[2]=mesh->Volus[i]->Lines[2];
   }
   /* 第四条边 */
   if(mesh->Lines[mesh->Volus[i]->Lines[3]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[1])
   {
    mesh->Volus[NV+i*7+0]->Lines[3]=mesh->Volus[i]->Lines[3];
    mesh->Volus[NV+i*7+1]->Lines[3]=mesh->Volus[i]->Lines[3]+NE;
   }
   else
   {
    mesh->Volus[NV+i*7+0]->Lines[3]=mesh->Volus[i]->Lines[3]+NE;
    mesh->Volus[NV+i*7+1]->Lines[3]=mesh->Volus[i]->Lines[3];
   }
   /* 第五条边  */
   if(mesh->Lines[mesh->Volus[i]->Lines[4]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[1])
   {
    mesh->Volus[NV+i*7+0]->Lines[4]=mesh->Volus[i]->Lines[4];
    mesh->Volus[NV+i*7+2]->Lines[4]=mesh->Volus[i]->Lines[4]+NE;
   }
   else
   {
    mesh->Volus[NV+i*7+0]->Lines[4]=mesh->Volus[i]->Lines[4]+NE;
    mesh->Volus[NV+i*7+2]->Lines[4]=mesh->Volus[i]->Lines[4];
   }
   /* 第六条边 */
   if(mesh->Lines[mesh->Volus[i]->Lines[5]]->Verts[0]==mesh->Volus[NV+i*7+1]->Verts[2])
   {
    mesh->Volus[NV+i*7+1]->Lines[5]=mesh->Volus[i]->Lines[5];
    mesh->Volus[NV+i*7+2]->Lines[5]=mesh->Volus[i]->Lines[5]+NE;
   }
   else
   {
    mesh->Volus[NV+i*7+1]->Lines[5]=mesh->Volus[i]->Lines[5]+NE;
    mesh->Volus[NV+i*7+2]->Lines[5]=mesh->Volus[i]->Lines[5];
   }
   /* 第一个面 */
   if(  (mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[3])
   && (mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[2]) )
   {
    //第一个面上的边被那些单元包含  
    mesh->Volus[NV+i*7+0]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+1]->Lines[4]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+2]->Lines[3]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+4]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+6]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+5]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    //第一个面上的边被哪些面包含
    mesh->Faces[NF*4+i*8+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF*4+i*8+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF*4+i*8+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF*4+i*8+7]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF*4+i*8+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[5];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[5];

    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[3];

    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    //第一个面上产生的新面被哪些单元包含
    mesh->Volus[NV+i*7+0]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+1]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+2]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+1;

   } 
   else if (mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[3]
	    &&mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[2] )
   {
    mesh->Volus[NV+i*7+0]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+1]->Lines[4]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+2]->Lines[3]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+4]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+6]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+5]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
 
    mesh->Faces[NF*4+i*8+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF*4+i*8+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF*4+i*8+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF*4+i*8+7]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF*4+i*8+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;

    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[5];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[4];

    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[5];

    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+1]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+2]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+2;
   }
 
 else if (mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[3]
          &&mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[2] )
   {
    mesh->Volus[NV+i*7+0]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+1]->Lines[4]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+2]->Lines[3]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+4]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+6]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+5]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    
    mesh->Faces[NF*4+i*8+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF*4+i*8+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF*4+i*8+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF*4+i*8+7]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF*4+i*8+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[4];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[5];

    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[5];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[4];

    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+1]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+2]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+2;


   } 
 else if (mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[3]
          &&mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[2] )
   {
    mesh->Volus[NV+i*7+0]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+1]->Lines[4]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+2]->Lines[3]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+4]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+6]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+5]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
 
    mesh->Faces[NF*4+i*8+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+2; 
    mesh->Faces[NF*4+i*8+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF*4+i*8+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF*4+i*8+7]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF*4+i*8+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
  
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[5];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[4];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[5];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[3];

    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[4];

    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
 
    mesh->Volus[NV+i*7+0]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+1]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+2]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+0;


  } 
 else if (mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[3]
          &&mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[2] )
   {
    mesh->Volus[NV+i*7+0]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+1]->Lines[4]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+2]->Lines[3]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+4]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+6]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+5]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    
    mesh->Faces[NF*4+i*8+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF*4+i*8+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF*4+i*8+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF*4+i*8+7]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF*4+i*8+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
  
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[5];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[3];

    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[5];

    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+1]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+2]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+0;
} 
 //else(mesh->Faces[mesh->Volus[i].Faces[0]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[3]&&mesh->Faces[mesh->Volus[i]->Faces[0]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[2] )
else
   {
    mesh->Volus[NV+i*7+0]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+1]->Lines[4]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+2]->Lines[3]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+4]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+6]->Lines[5]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Volus[NV+i*7+5]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    
    mesh->Faces[NF*4+i*8+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF*4+i*8+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF*4+i*8+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF*4+i*8+7]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF*4+i*8+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
   
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+0]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[3];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+1]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[5];

    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[5];
    mesh->Faces[NF+mesh->Volus[i]->Faces[0]*3+2]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[3];

    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[0]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[0]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[0]*3+2;
  
    mesh->Volus[NV+i*7+0]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+0;
    mesh->Volus[NV+i*7+1]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+2;
    mesh->Volus[NV+i*7+2]->Faces[0]=NF+mesh->Volus[i]->Faces[0]*3+1;
   }
 

  /* 第二个面 */
   if(mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[0]==mesh->Volus[NV+i*7+1]->Verts[0]
      &&mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[1]==mesh->Volus[NV+i*7+1]->Verts[3])
   {
    mesh->Volus[i]->Lines[5]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+3]->Lines[3]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+5]->Lines[4]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+6]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
  
    mesh->Faces[NF*4+i*8+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF*4+i*8+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF*4+i*8+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF*4+i*8+7]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF*4+i*8+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+0;

 
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[5];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[2]=mesh->Volus[i]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[0]=mesh->Volus[i]->Lines[1];

    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[5];

    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;

    mesh->Volus[NV+i*7+1]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+2]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[i]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+1;

 }  
   else if(mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[1]==mesh->Volus[NV+i*7+1]->Verts[0]
	   &&mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[0]==mesh->Volus[NV+i*7+1]->Verts[3])
   {
    mesh->Volus[i]->Lines[5]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+3]->Lines[3]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+5]->Lines[4]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+6]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
   
    mesh->Faces[NF*4+i*8+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF*4+i*8+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF*4+i*8+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF*4+i*8+7]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF*4+i*8+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[2]=mesh->Volus[i]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[1]=mesh->Volus[i]->Lines[1];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[5];

    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[5];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[1];

    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;

    mesh->Volus[NV+i*7+1]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+2]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[i]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+0;



}  
   else if(mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[2]==mesh->Volus[NV+i*7+1]->Verts[0]
	   &&mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[0]==mesh->Volus[NV+i*7+1]->Verts[3])
   {
    mesh->Volus[i]->Lines[5]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+3]->Lines[3]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+5]->Lines[4]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+6]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
  
    mesh->Faces[NF*4+i*8+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF*4+i*8+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF*4+i*8+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF*4+i*8+7]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF*4+i*8+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[2]=mesh->Volus[i]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[1]=mesh->Volus[i]->Lines[2];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[5];

    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[5];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[2];

    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
 
    mesh->Volus[NV+i*7+1]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+2]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[i]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+0;



 }  
   else if(mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[0]==mesh->Volus[NV+i*7+1]->Verts[0]
	   &&mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[2]==mesh->Volus[NV+i*7+1]->Verts[3])
   {
    mesh->Volus[i]->Lines[5]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+3]->Lines[3]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+5]->Lines[4]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+6]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
  
    mesh->Faces[NF*4+i*8+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF*4+i*8+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF*4+i*8+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF*4+i*8+7]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF*4+i*8+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
  
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[5];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[2];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[5];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[1];

    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[0]=mesh->Volus[i]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[1]=mesh->Volus[i]->Lines[2];

    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;

    mesh->Volus[NV+i*7+1]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+2]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[i]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+2;


}  
   else if(mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[1]==mesh->Volus[NV+i*7+1]->Verts[0]
	   &&mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[2]==mesh->Volus[NV+i*7+1]->Verts[3])
   {
    mesh->Volus[i]->Lines[5]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+3]->Lines[3]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+5]->Lines[4]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+6]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+1;

    mesh->Faces[NF*4+i*8+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF*4+i*8+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF*4+i*8+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF*4+i*8+7]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF*4+i*8+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;

    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[5];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[1];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[5];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[2];

    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[0]=mesh->Volus[i]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[1]=mesh->Volus[i]->Lines[1];

    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;

    mesh->Volus[NV+i*7+1]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+2]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[i]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+2;


 }  
   //else (mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[2]==mesh->Volus[NV+i*7+1]->Verts[0]&&mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[1]==mesh->Volus[NV+i*7+1]->Verts[3])
else   
  {
    mesh->Volus[i]->Lines[5]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+2]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+3]->Lines[3]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+5]->Lines[4]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Volus[NV+i*7+5]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+6]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[NV+i*7+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
   
    mesh->Faces[NF*4+i*8+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF*4+i*8+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF*4+i*8+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF*4+i*8+7]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF*4+i*8+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+2;

  
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+0]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[5];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[2]=mesh->Volus[i]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+1]->Lines[0]=mesh->Volus[i]->Lines[2];

    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[1]*3+2]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[5];

    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[1]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[1]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[1]*3+2;

    mesh->Volus[NV+i*7+1]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+0;
    mesh->Volus[NV+i*7+2]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+2;
    mesh->Volus[i]->Faces[1]=NF+mesh->Volus[i]->Faces[1]*3+1;
}


  /* 第三个面 */
   if(mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[0]
      &&mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[3])
   {
    mesh->Volus[i]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+4]->Lines[3]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+6]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+4]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
  
    mesh->Faces[NF*4+i*8+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF*4+i*8+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF*4+i*8+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF*4+i*8+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF*4+i*8+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+0;

   
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[4];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[2]=mesh->Volus[i]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[0]=mesh->Volus[i]->Lines[0];

    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[4];

    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+2]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[i]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+1;


 }  
   else if(mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[0]
	 &&mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[3])
   {
    mesh->Volus[i]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+4]->Lines[3]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+6]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+4]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
   
    mesh->Faces[NF*4+i*8+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF*4+i*8+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF*4+i*8+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF*4+i*8+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF*4+i*8+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[2];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[0];

    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[0]=mesh->Volus[i]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[1]=mesh->Volus[i]->Lines[2];

    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+2]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[i]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+2;



   }  
   else if(mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[0]
	 &&mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[3])
   {
    mesh->Volus[i]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+4]->Lines[3]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+6]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+4]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
   
    mesh->Faces[NF*4+i*8+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF*4+i*8+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF*4+i*8+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF*4+i*8+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF*4+i*8+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[0];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[2];

    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[0]=mesh->Volus[i]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[1]=mesh->Volus[i]->Lines[0];

    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+2]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[i]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+2;



   }  
   else if(mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[0]
	 &&mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[3])
   {
    mesh->Volus[i]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+4]->Lines[3]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+6]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+4]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    
    mesh->Faces[NF*4+i*8+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF*4+i*8+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF*4+i*8+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF*4+i*8+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF*4+i*8+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[2]=mesh->Volus[i]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[1]=mesh->Volus[i]->Lines[0];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[2]=mesh->Volus[NV+i*7+2]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[4];

    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[0];

    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+2]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[i]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+0;


   }  
   else if(mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[0]
	 &&mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[3])
   {
    mesh->Volus[i]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+4]->Lines[3]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+6]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+4]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    
    mesh->Faces[NF*4+i*8+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF*4+i*8+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF*4+i*8+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF*4+i*8+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF*4+i*8+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[2]=mesh->Volus[i]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[1]=mesh->Volus[i]->Lines[2];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[4];

    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[4];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[2];

    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+2]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[i]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+0;


   }  
   //else (mesh->Faces[mesh->Volus[i]->Faces[2]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[0]&&mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[3])
else
   {
    mesh->Volus[i]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+4]->Lines[3]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+6]->Lines[4]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[NV+i*7+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+4]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Volus[NV+i*7+3]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;

    mesh->Faces[NF*4+i*8+1]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF*4+i*8+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF*4+i*8+6]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF*4+i*8+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF*4+i*8+5]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+0]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[4];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[2]=mesh->Volus[i]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+1]->Lines[0]=mesh->Volus[i]->Lines[2];

    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[0]=mesh->Volus[NV+i*7+2]->Lines[2];
    mesh->Faces[NF+mesh->Volus[i]->Faces[2]*3+2]->Lines[1]=mesh->Volus[NV+i*7+2]->Lines[4];

    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[2]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[2]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[2]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+0;
    mesh->Volus[NV+i*7+2]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+2;
    mesh->Volus[i]->Faces[2]=NF+mesh->Volus[i]->Faces[2]*3+1;



   }  
 /* 第四个面 */
   if(mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[0]
     &&mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[2])
   {
    mesh->Volus[i]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+3]->Lines[4]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+5]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
   
    mesh->Faces[NF*4+i*8+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF*4+i*8+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF*4+i*8+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF*4+i*8+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF*4+i*8+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[3];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[2]=mesh->Volus[i]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[0]=mesh->Volus[i]->Lines[0];

    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[3];

    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+1]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[i]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+1;



}  
   else if(mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[0]
	 &&mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[2])
   {
    mesh->Volus[i]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+3]->Lines[4]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+5]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
   
    mesh->Faces[NF*4+i*8+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF*4+i*8+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF*4+i*8+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF*4+i*8+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF*4+i*8+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[1];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[0];

    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[0]=mesh->Volus[i]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[1]=mesh->Volus[i]->Lines[1];

    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+1]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[i]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+2;


}  
  else if(mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[0]
	&&mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[2])
   {
    mesh->Volus[i]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+3]->Lines[4]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+5]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
   
    mesh->Faces[NF*4+i*8+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF*4+i*8+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF*4+i*8+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF*4+i*8+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF*4+i*8+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[0];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[1];

    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[0]=mesh->Volus[i]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[1]=mesh->Volus[i]->Lines[0];

    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+1]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[i]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+2;


   }  
  else if(mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[0]
	&&mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[2])
   {
    mesh->Volus[i]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+3]->Lines[4]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+5]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
  
    mesh->Faces[NF*4+i*8+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF*4+i*8+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF*4+i*8+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF*4+i*8+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF*4+i*8+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[2]=mesh->Volus[i]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[1]=mesh->Volus[i]->Lines[0];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[2]=mesh->Volus[NV+i*7+1]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[3];

    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[0];

    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+1]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[i]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+0;

   }  
  else if(mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[0]
	&&mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[0]==mesh->Volus[NV+i*7+0]->Verts[2])
   {
    mesh->Volus[i]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+3]->Lines[4]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+5]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
  
    mesh->Faces[NF*4+i*8+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF*4+i*8+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF*4+i*8+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF*4+i*8+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF*4+i*8+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[2]=mesh->Volus[i]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[1]=mesh->Volus[i]->Lines[1];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[0]=mesh->Volus[NV+i*7+0]->Lines[3];

    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[3];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[1];

    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+1]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[i]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+0;



 }  
 // else (mesh->Faces[mesh->Volus[i]->Faces[3]]->Verts[2]==mesh->Volus[NV+i*7+0]->Verts[0]&&mesh->Faces[mesh->Volus[i]->Faces[1]]->Verts[1]==mesh->Volus[NV+i*7+0]->Verts[2])
else
   {
    mesh->Volus[i]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+0]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+1]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+3]->Lines[4]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+5]->Lines[3]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[NV+i*7+3]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Volus[NV+i*7+3]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+4]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
  
  
    mesh->Faces[NF*4+i*8+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF*4+i*8+0]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF*4+i*8+6]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF*4+i*8+2]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF*4+i*8+4]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
 
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[2]=mesh->Volus[NV+i*7+0]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+0]->Lines[1]=mesh->Volus[NV+i*7+0]->Lines[3];
    
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[2]=mesh->Volus[i]->Lines[0];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+1]->Lines[0]=mesh->Volus[i]->Lines[1];

    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[0]=mesh->Volus[NV+i*7+1]->Lines[1];
    mesh->Faces[NF+mesh->Volus[i]->Faces[3]*3+2]->Lines[1]=mesh->Volus[NV+i*7+1]->Lines[3];

    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[0]=NE*2+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[1]=NE*2+mesh->Volus[i]->Faces[3]*3+1;
    mesh->Faces[mesh->Volus[i]->Faces[3]]->Lines[2]=NE*2+mesh->Volus[i]->Faces[3]*3+2;

    mesh->Volus[NV+i*7+0]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+0;
    mesh->Volus[NV+i*7+1]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+2;
    mesh->Volus[i]->Faces[3]=NF+mesh->Volus[i]->Faces[3]*3+1;
  }  


   //更新最中间的一条边被哪个单元哪个面包含
   mesh->Volus[NV+i*7+3]->Lines[5]=NE*2+NF*3+i;
   mesh->Volus[NV+i*7+4]->Lines[4]=NE*2+NF*3+i;
   mesh->Volus[NV+i*7+5]->Lines[5]=NE*2+NF*3+i;
   mesh->Volus[NV+i*7+6]->Lines[3]=NE*2+NF*3+i;
  
   mesh->Faces[NF*4+i*8+4]->Lines[0]=NE*2+NF*3+i;
   mesh->Faces[NF*4+i*8+5]->Lines[1]=NE*2+NF*3+i;
   mesh->Faces[NF*4+i*8+6]->Lines[0]=NE*2+NF*3+i;
   mesh->Faces[NF*4+i*8+7]->Lines[0]=NE*2+NF*3+i; 
   
   //更新不用判断顺序的面
   mesh->Volus[i]->Faces[0]=NF*4+i*8+0;
   mesh->Volus[NV+i*7+0]->Faces[1]=NF*4+i*8+1;
   mesh->Volus[NV+i*7+1]->Faces[2]=NF*4+i*8+2;
   mesh->Volus[NV+i*7+2]->Faces[3]=NF*4+i*8+3;

   mesh->Volus[NV+i*7+3]->Faces[0]=NF*4+i*8+4;
   mesh->Volus[NV+i*7+3]->Faces[1]=NF*4+i*8+6;
   mesh->Volus[NV+i*7+3]->Faces[2]=num_face[3];
   mesh->Volus[NV+i*7+3]->Faces[3]=NF*4+i*8+0;

   mesh->Volus[NV+i*7+4]->Faces[0]=NF*4+i*8+5;
   mesh->Volus[NV+i*7+4]->Faces[1]=NF*4+i*8+1;
   mesh->Volus[NV+i*7+4]->Faces[2]=NF*4+i*8+6;
   mesh->Volus[NV+i*7+4]->Faces[3]=num_face[2];

   mesh->Volus[NV+i*7+5]->Faces[0]=NF*4+i*8+4;
   mesh->Volus[NV+i*7+5]->Faces[1]=NF*4+i*8+7;
   mesh->Volus[NV+i*7+5]->Faces[2]=num_face[1];
   mesh->Volus[NV+i*7+5]->Faces[3]=NF*4+i*8+2;

   mesh->Volus[NV+i*7+6]->Faces[0]=NF*4+i*8+5;
   mesh->Volus[NV+i*7+6]->Faces[1]=num_face[0];
   mesh->Volus[NV+i*7+6]->Faces[2]=NF*4+i*8+3;
   mesh->Volus[NV+i*7+6]->Faces[3]=NF*4+i*8+7;
}
//更新边界
/*
mesh->geo_bdry.faces_idxes=realloc(mesh->geo_bdry.faces_idxes,mesh->geo_bdry.nfaces*4*sizeof(int));
mesh->geo_bdry.face_bdry_idxes=realloc(mesh->geo_bdry.face_bdry_idxes,mesh->geo_bdry.nfaces*4*sizeof(int));

mesh->geo_bdry.edges_idxes=realloc(mesh->geo_bdry.edges_idxes,mesh->geo_bdry.nedges*2*sizeof(int));
mesh->geo_bdry.edge_bdry_idxes=realloc(mesh->geo_bdry.edge_bdry_idxes,mesh->geo_bdry.nedges*2*sizeof(int));

for(i=0;i<mesh->geo_bdry.nedges;++i)
    {
      num=i+mesh->geo_bdry.nedges;
      mesh->geo_bdry.edges_idxes[num]=mesh->geo_bdry.edges_idxes[i]+mesh->Num_Lines_Global;
      mesh->geo_bdry.edge_bdry_idxes[num]=mesh->geo_bdry.edge_bdry_idxes[i];
    }
mesh->geo_bdry.nedges*=2;
for(i=0;i<mesh->geo_bdry.nfaces;++i)
    {
      num=i*3+mesh->geo_bdry.nfaces;
      mesh->geo_bdry.faces_idxes[num]=mesh->geo_bdry.faces_idxes[i]*3+mesh->Num_Faces_Global;
      mesh->geo_bdry.face_bdry_idxes[num]=mesh->geo_bdry.face_bdry_idxes[i];
      mesh->geo_bdry.faces_idxes[num+1]=mesh->geo_bdry.faces_idxes[i]*3+mesh->Num_Faces_Global+1;
      mesh->geo_bdry.face_bdry_idxes[num+1]=mesh->geo_bdry.face_bdry_idxes[i];
      mesh->geo_bdry.faces_idxes[num+2]=mesh->geo_bdry.faces_idxes[i]*3+mesh->Num_Faces_Global+2;
      mesh->geo_bdry.face_bdry_idxes[num+2]=mesh->geo_bdry.face_bdry_idxes[i];
    }
mesh->geo_bdry.nfaces*=4;
*/
mesh->Num_Verts_Global=tmp_nverts;
mesh->Num_Lines_Global=tmp_nedges;
mesh->Num_Faces_Global=tmp_nfaces;
mesh->Num_Volus_Global=tmp_nvolus;

mesh->get_full_info=0;
return;
}
void
MeshFullInfoConsistent(MESH *mesh)
{
   int i, curr_edge, curr_face, curr_volu;
   VERT *vert;
   LINE *edge;
   FACEE *face;
   VOLU *volu;
   int nvolus_local=mesh->Num_Volus_Global;
   int nfaces_local=mesh->Num_Faces_Global;
   int nedges_local=mesh->Num_Lines_Global;
   int nverts_local=mesh->Num_Verts_Global;

   //if(mesh->get_full_info==1) return;
   //else mesh->get_full_info=1;
   
   for(i=0;i<nverts_local;++i)
   {
      mesh->Verts[i]->Num_Lines_Owned=0;
      mesh->Verts[i]->Num_Faces_Owned=0;
      mesh->Verts[i]->Num_Volus_Owned=0;
   }
 
   for(i=0;i<nedges_local;++i)
   {
      mesh->Lines[i]->Num_Faces_Owned=0;
      mesh->Lines[i]->Num_Volus_Owned=0;
   }
   for(i=0;i<nfaces_local;++i)
   {
      mesh->Faces[i]->Num_Volus_Owned=0;
   }
//遍历单元，更新点边面关于ｖｏｌｕｓ的个数
  for(curr_volu=0;curr_volu<nvolus_local;++curr_volu)
  {
    volu=&mesh->Volus[curr_volu];
    for(i=0;i<NVERTS_PER_VOLU;++i)
     mesh->Verts[volu->Verts[i]]->Num_Volus_Owned+=1;
    for(i=0;i<NLINES_PER_VOLU;++i)
     mesh->Lines[volu->Lines[i]]->Num_Volus_Owned+=1;
    for(i=0;i<NFACEES_PER_VOLU;++i)
     mesh->Faces[volu->Faces[i]]->Num_Volus_Owned+=1;
  }
//遍历面，更新点边关于ｆａｃｅｓ的个数
  for(curr_face=0;curr_face<nfaces_local;++curr_face)
  {
    face=&mesh->Faces[curr_face];
    for(i=0;i<NVERTS_PER_FACEE;++i)
     mesh->Verts[face->Verts[i]]->Num_Faces_Owned+=1;
    for(i=0;i<NLINES_PER_FACEE;++i)
     mesh->Lines[face->Lines[i]]->Num_Faces_Owned+=1;
  }
//遍历边，更新点关于ｅｄｇｅｓ的个数
  for(curr_edge=0;curr_edge<nedges_local;++curr_edge)
  {
    edge=&mesh->Lines[curr_edge];
    for(i=0;i<NVERTS_PER_LINE;++i)
     mesh->Verts[edge->Verts[i]]->Num_Lines_Owned+=1;
  }
//分配内存
  for(i=0;i<nverts_local;++i)
  {
     if(mesh->Verts[i]->Lines_Owned!=NULL){
	mesh->Verts[i]->Lines_Owned=realloc(mesh->Verts[i]->Lines_Owned,mesh->Verts[i]->Num_Lines_Owned*sizeof(int));
     }
     else{
	mesh->Verts[i]->Lines_Owned=malloc(mesh->Verts[i]->Num_Lines_Owned*sizeof(int));
     }
     if(mesh->Verts[i]->Faces_Owned!=NULL){
	mesh->Verts[i]->Faces_Owned=realloc(mesh->Verts[i]->Faces_Owned,mesh->Verts[i]->Num_Faces_Owned*sizeof(int));
     }
     else{
	mesh->Verts[i]->Faces_Owned=malloc(mesh->Verts[i]->Num_Faces_Owned*sizeof(int));
     }
     if(mesh->Verts[i]->Volus_Owned!=NULL){
	mesh->Verts[i]->Volus_Owned=realloc(mesh->Verts[i]->Volus_Owned,mesh->Verts[i]->Num_Volus_Owned*sizeof(int));
     }
     else{
	mesh->Verts[i]->Volus_Owned=malloc(mesh->Verts[i]->Num_Volus_Owned*sizeof(int));
     }
  mesh->Verts[i]->Mark=0;
  }
  for(i=0;i<nedges_local;++i)
  {
     if(mesh->Lines[i]->Faces_Owned!=NULL){
	mesh->Lines[i]->Faces_Owned=realloc(mesh->Lines[i]->Faces_Owned,mesh->Lines[i]->Num_Faces_Owned*sizeof(int));
     }
     else{
	mesh->Lines[i]->Faces_Owned=malloc(mesh->Lines[i]->Num_Faces_Owned*sizeof(int));
     }
     if(mesh->Lines[i]->Volus_Owned!=NULL){
	mesh->Lines[i]->Volus_Owned=realloc(mesh->Lines[i]->Volus_Owned,mesh->Lines[i]->Num_Volus_Owned*sizeof(int));
     }
     else{
	mesh->Lines[i]->Volus_Owned=malloc(mesh->Lines[i]->Num_Volus_Owned*sizeof(int));
     }
  mesh->Lines[i]->Mark=0;
  }
     
  for(i=0;i<nfaces_local;++i)
  {
     if(mesh->Faces[i]->Volus_Owned!=NULL){
	mesh->Faces[i]->Volus_Owned=realloc(mesh->Faces[i]->Volus_Owned,mesh->Faces[i]->Num_Volus_Owned*sizeof(int));
     }
     else{
	mesh->Faces[i]->Volus_Owned=malloc(mesh->Faces[i]->Num_Volus_Owned*sizeof(int));
     }
  mesh->Faces[i]->Count=0;
  }
     
//遍历单元，更新点边面关于ｖｏｌｕｓ的ｏｗｎ值
 for(curr_volu=0;curr_volu<nvolus_local;++curr_volu)
 {
   volu=&mesh->Volus[curr_volu];
   for(i=0;i<NVERTS_PER_VOLU;++i)
   {
     vert=&mesh->Verts[volu->Verts[i]];
     vert->Volus_Owned[vert->Mark++]=curr_volu; 
   }
   for(i=0;i<NLINES_PER_VOLU;++i)
   {
     edge=&mesh->Lines[volu->Lines[i]];
     edge->Volus_Owned[edge->Mark++]=curr_volu; 
   }
for(i=0;i<NFACEES_PER_VOLU;++i)
   {
     face=&mesh->Faces[volu->Faces[i]];
     face->Volus_Owned[face->Count++]=curr_volu; 
   }

 }

 for(i=0;i<nverts_local;++i)
    mesh->Verts[i]->Mark=0;
 for(i=0;i<nedges_local;++i)
    mesh->Lines[i]->Mark=0;
 for(curr_face=0;curr_face<nfaces_local;++curr_face)
 {
   face=&mesh->Faces[curr_face];
   for(i=0;i<NVERTS_PER_FACEE;++i)
   {
     vert=&mesh->Verts[face->Verts[i]];
     vert->Faces_Owned[vert->Mark++]=curr_face;
   }
   for(i=0;i<NLINES_PER_FACEE;++i)
   {
     edge=&mesh->Lines[face->Lines[i]];
     edge->Faces_Owned[edge->Mark++]=curr_face;
   }
 }

  for(i=0;i<nverts_local;++i)
    mesh->Verts[i]->Mark=0;
 for(curr_edge=0;curr_edge<nedges_local;++curr_edge)
 {
   edge=&mesh->Lines[curr_edge];
   for(i=0;i<NVERTS_PER_LINE;++i)
   {
     vert=&mesh->Verts[edge->Verts[i]];
     vert->Lines_Owned[vert->Mark++]=curr_edge;
   }
 }
}




//-----------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------
//-------------------------------------------自适应加密------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------
int MarkJudge(MESH *mesh,VOLU *volu)
{
  if(mesh->Lines[volu->Lines[0]]->Mark>=0&&mesh->Lines[volu->Lines[0]]->Child[0]<0) return 1;
  else if (mesh->Lines[volu->Lines[0]]->Mark>=0&&mesh->Lines[volu->Lines[0]]->Child[0]>=0
	&&volu->Verts[0]!=mesh->Lines[volu->Lines[0]]->Child[2]
	&&volu->Verts[1]!=mesh->Lines[volu->Lines[0]]->Child[2]) return 1;
  else if (mesh->Lines[volu->Lines[1]]->Mark>=0&&mesh->Lines[volu->Lines[1]]->Child[0]<0) return 1;
  else if (mesh->Lines[volu->Lines[1]]->Mark>=0&&mesh->Lines[volu->Lines[1]]->Child[0]>=0
	&&volu->Verts[0]!=mesh->Lines[volu->Lines[1]]->Child[2]
	&&volu->Verts[2]!=mesh->Lines[volu->Lines[1]]->Child[2]) return 1;
  else if (mesh->Lines[volu->Lines[2]]->Mark>=0&&mesh->Lines[volu->Lines[2]]->Child[0]<0) return 1;
  else if (mesh->Lines[volu->Lines[2]]->Mark>=0&&mesh->Lines[volu->Lines[2]]->Child[0]>=0
	&&volu->Verts[0]!=mesh->Lines[volu->Lines[2]]->Child[2]
	&&volu->Verts[3]!=mesh->Lines[volu->Lines[2]]->Child[2]) return 1;
  else if (mesh->Lines[volu->Lines[3]]->Mark>=0&&mesh->Lines[volu->Lines[3]]->Child[0]<0) return 1;
  else if (mesh->Lines[volu->Lines[3]]->Mark>=0&&mesh->Lines[volu->Lines[3]]->Child[0]>=0
	&&volu->Verts[1]!=mesh->Lines[volu->Lines[3]]->Child[2]
	&&volu->Verts[2]!=mesh->Lines[volu->Lines[3]]->Child[2]) return 1;
  else if (mesh->Lines[volu->Lines[4]]->Mark>=0&&mesh->Lines[volu->Lines[4]]->Child[0]<0) return 1; 
  else if (mesh->Lines[volu->Lines[4]]->Mark>=0&&mesh->Lines[volu->Lines[4]]->Child[0]>=0
	&&volu->Verts[1]!=mesh->Lines[volu->Lines[4]]->Child[2]
	&&volu->Verts[3]!=mesh->Lines[volu->Lines[4]]->Child[2]) return 1;
  else if (mesh->Lines[volu->Lines[5]]->Mark>=0&&mesh->Lines[volu->Lines[5]]->Child[0]<0) return 1;
  else if (mesh->Lines[volu->Lines[5]]->Mark>=0&&mesh->Lines[volu->Lines[5]]->Child[0]>=0
	&&volu->Verts[2]!=mesh->Lines[volu->Lines[5]]->Child[2]
	&&volu->Verts[3]!=mesh->Lines[volu->Lines[5]]->Child[2]) return 1;
  else return -1;
}

static int cmp(const void *a,const void *b)
{
    return *(double*)a-*(double*)b>0?0:1;  
}


void
QuickSort(void *x, int low, int high, size_t size, int *ix, int (*cmp)(const void *a,const void *b))
{
    int i, j, it, flag; size_t t;
    if (low < high) /*要排序的元素起止下标，保证小的放在左边，大的放在右边。这里以下标为low的元素为基准点*/
    {
	i = low; j = high;
	it = ix[0]; t = size*it;
	while (i<j) /*循环扫描*/
	{
	    flag = cmp((x+size*ix[j-low]), (x+t))>0?1:0;
	    while (i<j && flag) /*在右边的只要比基准点大仍放在右边*/
	    {
		j--; /*前移一个位置*/
		flag = cmp((x+size*ix[j-low]), (x+t))>0?1:0;
	    }
	    if (i<j)
	    {
		ix[i-low] = ix[j-low];
		i++; /*后移一个位置，并以此为基准点*/
	    }
	    flag = cmp((x+size*ix[i-low]), (x+t))>0?0:1;
	    while (i<j && flag) /*在左边的只要小于等于基准点仍放在左边*/
	    {
		i++; /*后移一个位置*/
		flag = cmp((x+size*ix[i-low]), (x+t))>0?0:1;
	    }
	    if (i<j)
	    {
		ix[j-low] = ix[i-low];
		j--; /*前移一个位置*/
	    }
	}
	ix[i-low] = it;
	QuickSort(x,low,i-1, size, ix, cmp);   /*对基准点左边的数再执行快速排序*/
	QuickSort(x,i+1,high, size, (ix+i+1-low), cmp);   /*对基准点右边的数再执行快速排序*/
    }
}


void MeshDestroy(MESH *mesh)
{
   int i;
   for(i=0;i<mesh->Num_Lines_Global;i++)
   {
      free(mesh->Lines[i]->Volus_Owned);
   }
   for(i=0;i<mesh->Num_Verts_Global;++i)
   {
      free(mesh->Verts[i]);
   }
   for(i=0;i<mesh->Num_Lines_Global;++i)
   {
      free(mesh->Lines[i]);
   }
   for(i=0;i<mesh->Num_Faces_Global;++i)
   {
      free(mesh->Faces[i]);
   }
   for(i=0;i<mesh->Num_Volus_Global;++i)
   {
      free(mesh->Volus[i]);
   }
    free(mesh->Verts);
    free(mesh->Lines);
    free(mesh->Faces);
    free(mesh->Volus);
    free(mesh);
    printf ( "Mesh Destroy\n" );
}



void
ReadMesh(MESH *mesh,char *file)
{
int i,j;
FILE *fp = fopen(file, "r");
fscanf(fp,"%d\n",&mesh->Num_Verts_Global);
mesh->Verts=malloc(mesh->Num_Verts_Global*sizeof(VERT*));
for(i=0;i<mesh->Num_Verts_Global;++i)
{
mesh->Verts[i]=malloc(1*sizeof(VERT));
}
for(i=0;i<mesh->Num_Verts_Global;++i)
{
  fscanf(fp,"%lf %lf %lf\n", &(mesh->Verts[i]->Coord[0]), &(mesh->Verts[i]->Coord[1]),&(mesh->Verts[i]->Coord[2]));
}
fscanf(fp,"%d\n",&mesh->Num_Lines_Global);
mesh->Lines=malloc(mesh->Num_Lines_Global*sizeof(LINE*));
for(i=0;i<mesh->Num_Lines_Global;++i)
{
mesh->Lines[i]=malloc(1*sizeof(LINE));
}
for(i=0;i<mesh->Num_Lines_Global;++i)
{
fscanf(fp,"%d %d\n",&mesh->Lines[i]->Verts[0],&mesh->Lines[i]->Verts[1]);
fscanf(fp,"%d\n",&mesh->Lines[i]->Mark);
fscanf(fp,"%d\n",&mesh->Lines[i]->ID_Boundary);
fscanf(fp,"%d %d %d\n",&mesh->Lines[i]->Child[0],&mesh->Lines[i]->Child[1],&mesh->Lines[i]->Child[2]);
fscanf(fp,"%d\n",&mesh->Lines[i]->Num_Volus_Owned);
mesh->Lines[i]->Volus_Owned=(int*)malloc(sizeof(int)*(mesh->Lines[i]->Num_Volus_Owned));
for(j=0;j<mesh->Lines[i]->Num_Volus_Owned;++j) 
   fscanf(fp,"%d",&mesh->Lines[i]->Volus_Owned[j]); 
   fscanf(fp,"\n");
}
fscanf(fp,"%d\n",&mesh->Num_Faces_Global);
mesh->Faces=malloc(sizeof(FACEE*)*mesh->Num_Faces_Global);
for(i=0;i<mesh->Num_Faces_Global;++i)
{
mesh->Faces[i]=malloc(1*sizeof(FACEE));
}
for(i=0;i<mesh->Num_Faces_Global;++i)
{
 fscanf(fp,"%d %d %d\n",&mesh->Faces[i]->Verts[0],&mesh->Faces[i]->Verts[1],&mesh->Faces[i]->Verts[2]);
 fscanf(fp,"%d %d %d\n",&mesh->Faces[i]->Lines[0],&mesh->Faces[i]->Lines[1],&mesh->Faces[i]->Lines[2]);
fscanf(fp,"%d %d %d %d %d\n",&mesh->Faces[i]->Child[0],&mesh->Faces[i]->Child[1],&mesh->Faces[i]->Child[2],&mesh->Faces[i]->Old_Child[0],&mesh->Faces[i]->Old_Child[1]);
fscanf(fp,"%d\n",&mesh->Faces[i]->ID_Boundary);
}
fscanf(fp,"%d\n",&mesh->Num_Volus_Global);
mesh->Volus=malloc(sizeof(VOLU*)*mesh->Num_Volus_Global);
for(i=0;i<mesh->Num_Volus_Global;++i)
{
mesh->Volus[i]=malloc(sizeof(VOLU));
}
for(i=0;i<mesh->Num_Volus_Global;++i)
{
 fscanf(fp,"%d %d %d %d\n",&mesh->Volus[i]->Verts[0],&mesh->Volus[i]->Verts[1],&mesh->Volus[i]->Verts[2],&mesh->Volus[i]->Verts[3]);
 fscanf(fp,"%d %d %d %d %d %d\n",&mesh->Volus[i]->Lines[0],&mesh->Volus[i]->Lines[1],&mesh->Volus[i]->Lines[2],
	&mesh->Volus[i]->Lines[3],&mesh->Volus[i]->Lines[4],&mesh->Volus[i]->Lines[5]);
 fscanf(fp,"%d %d %d %d\n",&mesh->Volus[i]->Faces[0],&mesh->Volus[i]->Faces[1],&mesh->Volus[i]->Faces[2],&mesh->Volus[i]->Faces[3]);
fscanf(fp,"%d %d\n",&mesh->Volus[i]->Child[0],&mesh->Volus[i]->Child[1]);
fscanf(fp,"%d\n",&mesh->Volus[i]->Type);
fscanf(fp,"%d\n",&mesh->Volus[i]->Mark);
fscanf(fp,"%d %d\n",&mesh->Volus[i]->Ancestor, &mesh->Volus[i]->Father);
}
/*
fscanf(fp,"%d", &mesh->geo_bdry->nlines);
mesh->geo_bdry->lines_idxes=(int*)malloc(sizeof(int)*mesh->geo_bdry->nlines);
mesh->geo_bdry->line_bdry_idxes=(int*)malloc(sizeof(int)*mesh->geo_bdry->nlines);
for(i=0;i<mesh->geo_bdry->nlines;++i)
  fscanf(fp,"%d",&mesh->geo_bdry->lines_idxes[i]);
  fscanf(fp,"\n");
for(i=0;i<mesh->geo_bdry->nlines;++i)
  fscanf(fp,"%d",&mesh->geo_bdry->line_bdry_idxes[i]);
  fscanf(fp,"\n");
fscanf(fp,"%d", &mesh->geo_bdry->nfaces);
mesh->geo_bdry->faces_idxes=(int*)malloc(sizeof(int)*mesh->geo_bdry->nfaces);
mesh->geo_bdry->face_bdry_idxes=(int*)malloc(sizeof(int)*mesh->geo_bdry->nfaces);
for(i=0;i<mesh->geo_bdry->nfaces;++i)
  fscanf(fp,"%d",&mesh->geo_bdry->faces_idxes[i]);
  fscanf(fp,"\n");
for(i=0;i<mesh->geo_bdry->nfaces;++i)
  fscanf(fp,"%d",&mesh->geo_bdry->face_bdry_idxes[i]);
  fscanf(fp,"\n");
fscanf(fp,"%d",&mesh->get_full_info);
*/
fclose(fp);

}





void WriteMesh(MESH *mesh, char *file)
{
    FILE *fp = fopen( file,"w");
    int i,j;
    /* 输出体的信息 */
    VOLU *e;
    fprintf (fp, "# vtk DataFile Version 2->0\n" );
    fprintf (fp, "Tetrahedron example\n" );
    fprintf (fp, "ASCII\n" );
    fprintf (fp, "DATASET POLYDATA\n" );
    fprintf (fp, "POINTS %d float\n",mesh->Num_Verts_Global );
  
    VERT *v;
    for(i=0;i<mesh->Num_Verts_Global;i++)
    {
	v=mesh->Verts[i];
	fprintf (fp,  "%f %f %f\n", v->Coord[0],v->Coord[1],v->Coord[2]);
    }

   
   
   
    /* for(i=0;i<mesh->Num_Volus_Global;i++)
    {
	e=&(mesh->Volus[i]);
	    fprintf (fp,  "verts:%d,%d,%d,%d\n",e->Verts[0],e->Verts[1],e->Verts[2],e->Verts[3]);
	    fprintf (fp,  "lines:%d,%d,%d,%d,%d,%d\n",e->Lines[0],e->Lines[1],e->Lines[2],e->Lines[3],e->Lines[4],e->Lines[5]);
	    fprintf (fp,  "faces:%d,%d,%d,%d\n",e->Faces[0],e->Faces[1],e->Faces[2],e->Faces[3] );
	    fprintf (fp,  "\n" );
	
    }
    */
    /* 输出面的信息 */
    
    
 fprintf (fp,  "POLYGONS %d %d\n", mesh->Num_Faces_Global, mesh->Num_Faces_Global*4 );
 FACEE *f;
    for(i=0;i<mesh->Num_Faces_Global;i++)
    {
	f=mesh->Faces[i];
	fprintf (fp,  "%d %d %d %d\n",3,mesh->Faces[i]->Verts[0],mesh->Faces[i]->Verts[1],mesh->Faces[i]->Verts[2] );
    }
    fclose(fp);
}


void ShowMesh(MESH *mesh)
{
    int i,j;
    /* 输出体的信息 */
    VOLU *e;
    printf ( "Circle on the volus\n" );
    for(i=0;i<mesh->Num_Volus_Global;i++)
    {
	e=mesh->Volus[i];
	    printf ( "verts:%d,%d,%d,%d\n",e->Verts[0],e->Verts[1],e->Verts[2],e->Verts[3]);
	    printf ( "lines:%d,%d,%d,%d,%d,%d\n",e->Lines[0],e->Lines[1],e->Lines[2],e->Lines[3],e->Lines[4],e->Lines[5]);
	    printf ( "faces:%d,%d,%d,%d\n",e->Faces[0],e->Faces[1],e->Faces[2],e->Faces[3] );
   printf ( "type:%d\n",e->Type);
   printf ( "mark:%d\n",e->Mark);
   printf ( "Child:%d,%d\n",e->Child[0],e->Child[1] );

	    printf ( "\n" );
	
    }
    /* 输出面的信息 */
    FACEE *f;
    printf ( "Circle on the face\n" );
    for(i=0;i<mesh->Num_Faces_Global;i++)
    {
	f=mesh->Faces[i];
	printf ( "lines: %d,%d,%d\n",mesh->Faces[i]->Lines[0],mesh->Faces[i]->Lines[1],mesh->Faces[i]->Lines[2] );
	printf ( "verts:%d,%d,%d\n",mesh->Faces[i]->Verts[0],mesh->Faces[i]->Verts[1],mesh->Faces[i]->Verts[2] );
      	printf ( "ID_Boundary:%d\n",mesh->Faces[i]->ID_Boundary );
printf ( "Child:%d,%d,%d\n",mesh->Faces[i]->Child[0],mesh->Faces[i]->Child[1],mesh->Faces[i]->Child[2] );
}
    LINE *ed;
    printf ( "Circle on the line\n" );
    for(i=0;i<mesh->Num_Lines_Global;i++)
    {
	ed=mesh->Lines[i];
	printf ( "verts:%d,%d\n",ed->Verts[0],ed->Verts[1] );
	printf ( "Ownd by %ds simplex:",ed->Num_Volus_Owned );
	for(j=0;j<ed->Num_Volus_Owned;j++)
	    printf(" %d,",ed->Volus_Owned[j]);
	printf ( "\n" );
    printf ( "ID_Boundary:%d\n",ed->ID_Boundary);
   printf ( "mark:%d\n",ed->Mark);
   printf ( "Child:%d,%d\n",ed->Child[0],ed->Child[1],ed->Child[2] );
}
    VERT *v;
	printf ( "Circle on the verts\n" );
    for(i=0;i<mesh->Num_Verts_Global;i++)
    {
	v=mesh->Verts[i];
	printf ( "Coord:%f,%f,%f\n", v->Coord[0],v->Coord[1],v->Coord[2]);
	printf ( "\n" );
    }

}



//网格信息补全
void 
MeshFullInfo(MESH *mesh)
{
   int i, curr_line, curr_volu;
   LINE *line;
   VOLU *volu;
   int Num_Volus_Global=mesh->Num_Volus_Global;
   int Num_Lines_Global=mesh->Num_Lines_Global;
   for(i=0;i<Num_Lines_Global;++i)
   {
      mesh->Lines[i]->Num_Volus_Owned=0;
   }
//遍历单元，更新边关于ｖｏｌｕｓ的个数
  for(curr_volu=0;curr_volu<Num_Volus_Global;++curr_volu)
  {
    volu=mesh->Volus[curr_volu];
    for(i=0;i<NLINES_PER_VOLU;++i)
     mesh->Lines[volu->Lines[i]]->Num_Volus_Owned+=1;
  }
  printf ( "@@@@@@@@@@@@2\n" );
 // for(i=0;i<mesh->Num_Lines_Global;++i)
  //   printf ( "mesh->Lines->Num_Volus_Owned=%d,%d\n",i,mesh->Lines[i]->Num_Volus_Owned );
//分配内存
 for(i=0;i<Num_Lines_Global;++i)
  {
     if(mesh->Lines[i]->Volus_Owned==NULL)
	mesh->Lines[i]->Volus_Owned=malloc(mesh->Lines[i]->Num_Volus_Owned*sizeof(int));
     else
	mesh->Lines[i]->Volus_Owned=
	realloc(mesh->Lines[i]->Volus_Owned,mesh->Lines[i]->Num_Volus_Owned* sizeof(int));  
     mesh->Lines[i]->Count=0;
  }
 printf ( "##############\n" );
//遍历单元，更新点边面关于ｖｏｌｕｓ的ｏｗｎ值
 for(curr_volu=0;curr_volu<Num_Volus_Global;++curr_volu)
 {
   volu=mesh->Volus[curr_volu];
   for(i=0;i<NLINES_PER_VOLU;++i)
   {
     line=mesh->Lines[volu->Lines[i]];
     line->Volus_Owned[line->Count++]=curr_volu; 
   }
 }
}

//网格为下一次加密更新
void MeshRenew(MESH *mesh)
{
   int i;
   int nlines=mesh->Num_Lines_Global;
   int nfaces=mesh->Num_Faces_Global;
   int nvolus=mesh->Num_Volus_Global;
   for(i=0;i<nlines;++i)
   {
     mesh->Lines[i]->Mark=-1;
     mesh->Lines[i]->Child[0]=-1;
     mesh->Lines[i]->Child[1]=-1;
     mesh->Lines[i]->Child[2]=-1;
   }
  for(i=0;i<nfaces;++i)
   {
     mesh->Faces[i]->Old_Child[0]=-1;
     mesh->Faces[i]->Old_Child[1]=-1;
     mesh->Faces[i]->Child[0]=-1;
     mesh->Faces[i]->Child[1]=-1;
     mesh->Faces[i]->Child[2]=-1;
   }

 for(i=0;i<nvolus;++i)
   {
     mesh->Volus[i]->Mark=-1;
     mesh->Volus[i]->Child[0]=-1;
     mesh->Volus[i]->Child[1]=-1;
   }

}


int
GetLineNum(LINE *line,int line_num,VOLU *volu)
{
  if(line_num== volu->Lines[0])
   return 0;  
  else if(line_num== volu->Lines[1])
   return 1;  
  else if(line_num== volu->Lines[2])
   return 2;  
  else if(line_num==volu->Lines[3])
   return 3;  
  else if(line_num== volu->Lines[4])
   return 4;  
  else return 5;  
}





void
MarkMesh(MESH *mesh, VOLU *volu, int volu_num,LINE *line, int line_num, int *nline_mark)
{ 
  int k,j,i;
  VOLU *volu_owned;
  //LINE *line;
  if(volu->Mark==-1)//如果单元没被标记
  {//1
    volu->Mark=1;
    if(volu->Type==0){//1->1
       k=GetLineNum(line,line_num,volu);
       switch(k){
            case 0: break;
	    case 1: mesh->Lines[volu->Lines[0]]->Mark=*nline_mark;
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
		    break;
	    case 2: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
		    mesh->Lines[volu->Lines[1]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[1]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[1]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[1]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[1]],volu->Lines[1],
			       nline_mark);
		     }
		    break;
	    case 3: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
		    mesh->Lines[volu->Lines[4]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[4]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[4]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[4]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[4]],volu->Lines[4],
			       nline_mark);
		     }
		    break;
	    case 4: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
		    break;
	    case 5: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
		    mesh->Lines[volu->Lines[1]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[1]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[1]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[1]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[1]],volu->Lines[1],
			       nline_mark);
		     }
		    mesh->Lines[volu->Lines[4]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[4]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[4]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[4]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[4]],volu->Lines[4],
			       nline_mark);
		     }
		    break;
	    default:printf ( "line type is not conforming\n" ); break;
       }

    }//1->1
    else if(volu->Type==1){//1.2
       k=GetLineNum(line,line_num,volu);
       switch(k){
            case 0: break;
	    case 1: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
		    break;
	    case 2: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
		    mesh->Lines[volu->Lines[1]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[1]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[1]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[1]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[1]],volu->Lines[1],
			       nline_mark);
		     }
		    break;
	    case 3: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
		    break;
	    case 4: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
                    mesh->Lines[volu->Lines[3]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[3]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[3]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[3]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[3]],volu->Lines[3],
			       nline_mark);
		     }
		    break;
	    case 5: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
                    mesh->Lines[volu->Lines[1]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[1]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[1]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[1]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[1]],volu->Lines[1],
			       nline_mark);
		     }
                    mesh->Lines[volu->Lines[3]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[3]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[3]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[3]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[3]],volu->Lines[3],
			       nline_mark);
		     }
		    break;
	    default:printf ( "line type is not conforming\n" ); break;
       }
    }//1->2
    else{//1->3
       k=GetLineNum(line,line_num,volu);
       switch(k){
            case 0: break;
	    case 1: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
		    break;
	    case 2: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }

		    mesh->Lines[volu->Lines[1]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[1]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[1]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[1]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[1]],volu->Lines[1],
			       nline_mark);
		     }
		    break;
	    case 3: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
		    break;
	    case 4: mesh->Lines[volu->Lines[0]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[0]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[0]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[0]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[0]],volu->Lines[0],
			       nline_mark);
		     }
                    mesh->Lines[volu->Lines[3]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[3]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[3]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[3]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[3]],volu->Lines[3],
			       nline_mark);
		     }
		    break;
	    default:printf ( "line type is not conforming\n" ); break;
       }

    }//1->3
  }//1
  else//如果单元被标记了
  {//2
    if(volu->Type==0){//2.1
       k=GetLineNum(line,line_num,volu);
       switch(k){
            case 0: break;
	    case 1: break;
	    case 2: if(mesh->Lines[volu->Lines[1]]->Mark==-1)
		    {
		    mesh->Lines[volu->Lines[1]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[1]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[1]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[1]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[1]],volu->Lines[1],
			       nline_mark);
		     }
		    }
		    break;
	    case 3: if(mesh->Lines[volu->Lines[4]]->Mark==-1)
		    {
		    mesh->Lines[volu->Lines[4]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[4]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[4]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[4]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[4]],volu->Lines[4],
			       nline_mark);
		     }
		    }
		    break;
	    case 4: break;
	    case 5: if(mesh->Lines[volu->Lines[1]]->Mark==-1)
		    {
		    mesh->Lines[volu->Lines[1]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[1]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[1]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[1]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[1]],volu->Lines[1],
			       nline_mark);
		     }
		    }
		    if(mesh->Lines[volu->Lines[4]]->Mark==-1)
		    {		    
		    mesh->Lines[volu->Lines[4]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[4]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[4]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[4]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[4]],volu->Lines[4],
			       nline_mark);
		     }
		    }
		    break;
	    default:printf ( "line type is not conforming\n" ); break;
       }
    
    }//2.1
    else if(volu->Type==1){//2.2
       k=GetLineNum(line,line_num,volu);
       switch(k){
            case 0: break;
	    case 1: break;
	    case 2: if(mesh->Lines[volu->Lines[1]]->Mark==-1)
		    {
		    mesh->Lines[volu->Lines[1]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[1]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[1]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[1]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[1]],volu->Lines[1],
			       nline_mark);
		     }
		    }
		    break;
	    case 3: break;
	    case 4: if(mesh->Lines[volu->Lines[3]]->Mark==-1)
		    {
                    mesh->Lines[volu->Lines[3]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[3]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[3]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[3]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[3]],volu->Lines[3],
			       nline_mark);
		     }
		    }
		    break;
	    case 5: if(mesh->Lines[volu->Lines[1]]->Mark==-1)
		    {
                    mesh->Lines[volu->Lines[1]]->Mark=(*nline_mark);
		    (*nline_mark)++;
                    for(i=0;i<mesh->Lines[volu->Lines[1]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[1]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[1]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[1]],volu->Lines[1],
			       nline_mark);
		     }
		    }
		    if(mesh->Lines[volu->Lines[3]]->Mark==-1)
		    {
                    mesh->Lines[volu->Lines[3]]->Mark=(*nline_mark);
		    (*nline_mark)++;
		    for(i=0;i<mesh->Lines[volu->Lines[3]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[3]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[3]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[3]],volu->Lines[3],
			       nline_mark);
		     }
		    }
		    break;
	    default:printf ( "line type is not conforming\n" ); break;
       }

    }//2->2
    else{//2.3
       k=GetLineNum(line,line_num,volu);
       switch(k){
            case 0: break;
	    case 1: break;
	    case 2: if(mesh->Lines[volu->Lines[1]]->Mark==-1)
		    {
		    for(i=0;i<mesh->Lines[volu->Lines[1]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[1]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[1]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[1]],volu->Lines[1],
			       nline_mark);
		     }
		    }
		    break;
	    case 3: break;
	    case 4: if(mesh->Lines[volu->Lines[3]]->Mark==-1)
		    {
		    for(i=0;i<mesh->Lines[volu->Lines[3]]->Num_Volus_Owned;++i)
                     {
		      volu_owned=mesh->Volus[mesh->Lines[volu->Lines[3]]->Volus_Owned[i]];	    
		      MarkMesh(mesh,volu_owned,mesh->Lines[volu->Lines[3]]->Volus_Owned[i],
			       mesh->Lines[volu->Lines[3]],volu->Lines[3],
			       nline_mark);
		     }
		    }
		    break;
	    default:printf ( "line type is not conforming\n" ); break;
       }


    }//2->3

  }//2
}






//网格二分加密
//
//               0
//                ->                                     网格的六个顶点 0,1,2,3,4,5按右手法则排序。
//               . . .                                  网格六条边按赵定点顺序：第零条边[0]:0-1
//              .   .   .                               [1]:0-2,[2]:0-3,[4]:1-2,[5]:1-3,[6]:2-3。
//             .     .     .                            四个面的编号为对应上方顶点编号：face[0]:1-2-3,
//            .    (2).       .                         face[1]:0-2-3,face[2]:0-3-1,face[3]:0-1-2. 
//         (0).        .         . (1)
//          .           . 3         . 
//         .          .    .           .
//        .    (4).             .(5)      .
//       .     .                     .       .
//      .  .                               .     .
//    1.............................................2           
//                       (3) 
void
MeshRefineBisection(MESH *mesh, int *M, int num)
{ 
  int i,j,s;
  int k=0;
  int tmp_line,tmp_face;
  int nlines_mark=0;
  VOLU *volu,*volu_owned;
  FACEE *face;
  LINE *line;

  //找到所有要加密的单元
  printf ( "+++++++++++++++++++++++++++++++++++++++++++++=\n" ); 
  for(i=0;i<mesh->Num_Volus_Global;++i)
    mesh->Volus[i]->Sign=-1;
  for(i=0;i<num;++i)
    mesh->Volus[M[i]]->Sign=1;
   for(i=0;i<num;++i)
printf ( "%d\n", mesh->Volus[M[i]]->Sign);
 printf ( "+++++++++++++++++++++++++++++++++++++++++++++=\n" ); 
 for(i=0;i<mesh->Num_Volus_Global;++i)
  {
    volu=mesh->Volus[i];//按误差指示子大小取出单元
    if(volu->Sign>0&&volu->Mark<0)
     {
       line=mesh->Lines[volu->Lines[0]];
       line->Mark=nlines_mark;
       nlines_mark++;
       volu->Mark=1;
       for(j=0;j<line->Num_Volus_Owned;++j)
       {
        volu_owned=mesh->Volus[line->Volus_Owned[j]];
        MarkMesh(mesh,volu_owned,line->Volus_Owned[j],line,volu->Lines[0],&nlines_mark);      	
       }
     }  
  }
  //计算新增加的边数
  int mark_line_on_face=0;
  for(i=0;i<mesh->Num_Faces_Global;++i)
{   
    face=mesh->Faces[i];
     for(j=0;j<3;++j)
     {
       if(mesh->Lines[face->Lines[j]]->Mark>=0)
       {
	  mark_line_on_face++;
       }
     }
  }     
  int mark_line_on_volu=0;
  int mark_line23_on_volu=0;
  for(i=0;i<mesh->Num_Volus_Global;++i)
  {
     volu=mesh->Volus[i];
     for(j=0;j<5;++j)
     {
	if(mesh->Lines[volu->Lines[j]]->Mark>=0)
	   mark_line_on_volu++;
     }
     if(mesh->Lines[volu->Lines[5]]->Mark>=0)
	   mark_line23_on_volu++;
  }
  int total_vert,total_line, total_face,total_volu;
  total_vert=mesh->Num_Verts_Global+nlines_mark;
  total_line=mesh->Num_Lines_Global+nlines_mark+mark_line_on_face+mark_line23_on_volu;
  total_face=mesh->Num_Faces_Global+mark_line_on_face+mark_line_on_volu+mark_line23_on_volu*3;
  total_volu=mesh->Num_Volus_Global+mark_line_on_volu+mark_line23_on_volu*2;
  mesh->Verts=realloc(mesh->Verts,total_vert*sizeof(VERT*));
  for(i=mesh->Num_Verts_Global;i<total_vert;++i)
  mesh->Verts[i]=malloc(sizeof(VERT));
  mesh->Lines=realloc(mesh->Lines,total_line*sizeof(LINE*));
  for(i=mesh->Num_Lines_Global;i<total_line;++i)
  mesh->Lines[i]=malloc(sizeof(LINE));
  mesh->Faces=realloc(mesh->Faces,total_face*sizeof(FACEE*));
  for(i=mesh->Num_Faces_Global;i<total_face;++i)
  mesh->Faces[i]=malloc(sizeof(FACEE));
  mesh->Volus=realloc(mesh->Volus,total_volu*sizeof(VOLU*));
  for(i=mesh->Num_Volus_Global;i<total_volu;++i)
  mesh->Volus[i]=malloc(sizeof(VOLU));
  
 //加密程序
 
 //首先更新边上的新点和新边
 for(i=0;i<mesh->Num_Lines_Global;++i)
 {
   if(mesh->Lines[i]->Mark>=0)
   {
    //新点  
    mesh->Verts[mesh->Num_Verts_Global+mesh->Lines[i]->Mark]->Coord[0]=   
    0.5*(mesh->Verts[mesh->Lines[i]->Verts[0]]->Coord[0]+mesh->Verts[mesh->Lines[i]->Verts[1]]->Coord[0]);
    mesh->Verts[mesh->Num_Verts_Global+mesh->Lines[i]->Mark]->Coord[1]=   
    0.5*(mesh->Verts[mesh->Lines[i]->Verts[0]]->Coord[1]+mesh->Verts[mesh->Lines[i]->Verts[1]]->Coord[1]);
    mesh->Verts[mesh->Num_Verts_Global+mesh->Lines[i]->Mark]->Coord[2]=   
    0.5*(mesh->Verts[mesh->Lines[i]->Verts[0]]->Coord[2]+mesh->Verts[mesh->Lines[i]->Verts[1]]->Coord[2]);
    //两条边
    mesh->Lines[mesh->Num_Lines_Global+mesh->Lines[i]->Mark]->Verts[0]=mesh->Num_Verts_Global+mesh->Lines[i]->Mark; 
    mesh->Lines[mesh->Num_Lines_Global+mesh->Lines[i]->Mark]->Verts[1]=mesh->Lines[i]->Verts[1];
    mesh->Lines[mesh->Num_Lines_Global+mesh->Lines[i]->Mark]->Mark=-1;
    mesh->Lines[mesh->Num_Lines_Global+mesh->Lines[i]->Mark]->Child[0]=-1;
    mesh->Lines[mesh->Num_Lines_Global+mesh->Lines[i]->Mark]->Child[1]=-1;
    mesh->Lines[mesh->Num_Lines_Global+mesh->Lines[i]->Mark]->Child[2]=-1;
    mesh->Lines[mesh->Num_Lines_Global+mesh->Lines[i]->Mark]->ID_Boundary=mesh->Lines[i]->ID_Boundary;
    mesh->Lines[mesh->Num_Lines_Global+mesh->Lines[i]->Mark]->Num_Volus_Owned=-1;
    mesh->Lines[mesh->Num_Lines_Global+mesh->Lines[i]->Mark]->Volus_Owned=NULL;
 
    mesh->Lines[i]->Verts[0]=mesh->Lines[i]->Verts[0];
    mesh->Lines[i]->Verts[1]=mesh->Num_Verts_Global+mesh->Lines[i]->Mark;
    mesh->Lines[i]->Child[0]=i;
    mesh->Lines[i]->Child[1]=mesh->Num_Lines_Global+mesh->Lines[i]->Mark;
    mesh->Lines[i]->Child[2]=mesh->Num_Verts_Global+mesh->Lines[i]->Mark;
   }
 }
 int Iter_volu=mesh->Num_Volus_Global;
  int idx_vert=mesh->Num_Verts_Global+nlines_mark;
  int idx_line=mesh->Num_Lines_Global+nlines_mark;
  int idx_face=mesh->Num_Faces_Global;
  int idx_volu=mesh->Num_Volus_Global;
  for(i=0;i<3;++i)
 {//加密三次循环
    for(j=0;j<Iter_volu;++j)
    {//单元遍历
      volu=mesh->Volus[j];
      if(volu->Mark<0) continue;
      if(volu->Type==0)
      {//type0

          if (  (mesh->Faces[volu->Faces[3]]->Child[0]<0&&mesh->Faces[volu->Faces[2]]->Child[0]<0)
	      ||(mesh->Faces[volu->Faces[3]]->Child[0]<0&&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		  &&mesh->Faces[volu->Faces[2]]->Child[2]==volu->Lines[4])
	      ||(mesh->Faces[volu->Faces[2]]->Child[0]<0&&mesh->Faces[volu->Faces[3]]->Child[0]>=0
	         &&mesh->Faces[volu->Faces[3]]->Child[2]==volu->Lines[3] )
	      ||(mesh->Faces[volu->Faces[3]]->Child[0]>=0
		 &&mesh->Faces[volu->Faces[3]]->Child[2]==volu->Lines[3]
		 &&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		 &&mesh->Faces[volu->Faces[2]]->Child[2]==volu->Lines[4])
	     )   
		  //if(mesh->Faces[volu->Faces[3]]->Child[0]<0
	   //&&mesh->Faces[volu->Faces[2]]->Child[0]<0)//第一种情况：两个面都没加密 
          {//1
	   //更新面上两条新边的信息 
	   mesh->Lines[idx_line]->Verts[1]= mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Lines[idx_line]->Mark=-1;
	   mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;
	   mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	   mesh->Lines[idx_line]->Volus_Owned=NULL;
           mesh->Lines[idx_line]->Child[0]=-1;
	   mesh->Lines[idx_line]->Child[1]=-1;
	   mesh->Lines[idx_line]->Child[2]=-1;
	   mesh->Lines[idx_line++]->Verts[0]=volu->Verts[2];

	   mesh->Lines[idx_line]->Verts[1]= mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Lines[idx_line]->Mark=-1;
	   mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	   mesh->Lines[idx_line]->Volus_Owned=NULL;
	   mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;
	   mesh->Lines[idx_line]->Child[0]=-1;
	   mesh->Lines[idx_line]->Child[1]=-1;
	   mesh->Lines[idx_line]->Child[2]=-1;
           mesh->Lines[idx_line++]->Verts[0]=volu->Verts[3];
           //更新第一个面上的信息
           mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
           mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
           mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;

	   mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;

           mesh->Faces[idx_face]->Lines[0]=idx_line-2;
           mesh->Faces[idx_face]->Lines[1]=
	   volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
           mesh->Faces[idx_face++]->Lines[2]=volu->Lines[3];

	   mesh->Faces[volu->Faces[3]]->Verts[0]=volu->Verts[0];
           mesh->Faces[volu->Faces[3]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[volu->Faces[3]]->Verts[2]=volu->Verts[2];
         
	   mesh->Faces[volu->Faces[3]]->Lines[0]=idx_line-2;
           mesh->Faces[volu->Faces[3]]->Lines[1]=volu->Lines[1];
           mesh->Faces[volu->Faces[3]]->Lines[2]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

	   mesh->Faces[volu->Faces[3]]->Old_Child[0]=mesh->Faces[volu->Faces[3]]->Child[1];
	   mesh->Faces[volu->Faces[3]]->Old_Child[1]=mesh->Faces[volu->Faces[3]]->Child[2];
	   mesh->Faces[volu->Faces[3]]->Child[0]=volu->Faces[3];
           mesh->Faces[volu->Faces[3]]->Child[1]=idx_face-1;
           mesh->Faces[volu->Faces[3]]->Child[2]=idx_line-2;
	   //更新第二个面上的信息
           mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[3];
           mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
      	   mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;
           mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;

           mesh->Faces[idx_face]->Lines[0]=idx_line-1;
           mesh->Faces[idx_face]->Lines[1]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
           mesh->Faces[idx_face++]->Lines[2]=volu->Lines[4];

	   mesh->Faces[volu->Faces[2]]->Verts[0]=volu->Verts[0];
           mesh->Faces[volu->Faces[2]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[volu->Faces[2]]->Verts[2]=volu->Verts[3];
         
           mesh->Faces[volu->Faces[2]]->Old_Child[0]=mesh->Faces[volu->Faces[2]]->Child[1];
           mesh->Faces[volu->Faces[2]]->Old_Child[1]=mesh->Faces[volu->Faces[2]]->Child[2];
	   mesh->Faces[volu->Faces[2]]->Child[0]=volu->Faces[2];
           mesh->Faces[volu->Faces[2]]->Child[1]=idx_face-1;
           mesh->Faces[volu->Faces[2]]->Child[2]=idx_line-1;

	   mesh->Faces[volu->Faces[2]]->Lines[0]=idx_line-1;
           mesh->Faces[volu->Faces[2]]->Lines[1]=volu->Lines[2];
           mesh->Faces[volu->Faces[2]]->Lines[2]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

           //更新中间的新面的信息
	   mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
           mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
         
	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
           mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;

	   mesh->Faces[idx_face]->ID_Boundary=-1;

	   mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
           mesh->Faces[idx_face]->Lines[1]=idx_line-1;
           mesh->Faces[idx_face++]->Lines[2]=idx_line-2;


	      //更新单元信息
	   mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
	   mesh->Volus[idx_volu]->Verts[1]=volu->Verts[3];
	   mesh->Volus[idx_volu]->Verts[2]=volu->Verts[2];
           mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];
           
	   mesh->Volus[idx_volu]->Lines[0]=volu->Lines[4];
	   mesh->Volus[idx_volu]->Lines[1]=volu->Lines[3];
	   mesh->Volus[idx_volu]->Lines[2]=
	   volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
 	   mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
           mesh->Volus[idx_volu]->Lines[4]=idx_line-1;
 	   mesh->Volus[idx_volu]->Lines[5]=idx_line-2;

	   if(i==0)
	   {
            mesh->Volus[idx_volu]->Father=j;
            mesh->Volus[j]->Father=j;
	   }
           else
            mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
            mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;

           mesh->Volus[idx_volu]->Type=1;

	   mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
	   mesh->Volus[idx_volu]->Faces[1]=idx_face-3;
	   mesh->Volus[idx_volu]->Faces[2]=idx_face-2;
           mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];

	   mesh->Volus[j]->Verts[0]=volu->Verts[0];
	   mesh->Volus[j]->Verts[1]=volu->Verts[2];
	   mesh->Volus[j]->Verts[2]=volu->Verts[3];
	   mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];


	   tmp_line=volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
           mesh->Volus[j]->Lines[0]=volu->Lines[1];
	   mesh->Volus[j]->Lines[1]=volu->Lines[2];
	   mesh->Volus[j]->Lines[2]=tmp_line;
	   mesh->Volus[j]->Lines[3]=volu->Lines[5];
           mesh->Volus[j]->Lines[4]=idx_line-2;
 	   mesh->Volus[j]->Lines[5]=idx_line-1;

	   tmp_face=volu->Faces[1];
	   mesh->Volus[j]->Faces[0]=idx_face-1;
	   mesh->Volus[j]->Faces[1]=volu->Faces[2];
	   mesh->Volus[j]->Faces[2]=volu->Faces[3];
	   mesh->Volus[j]->Faces[3]=tmp_face;

           mesh->Volus[j]->Type=1;

	   mesh->Volus[j]->Child[0]=j;
	   mesh->Volus[j]->Child[1]=idx_volu-1;

	  
	   if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
            mesh->Volus[j]->Mark=-1;
	   }
           if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
            mesh->Volus[idx_volu-1]->Mark=1;
	   }
	   else
	   mesh->Volus[idx_volu-1]->Mark=-1;

	  }//1
           //-----------------------------------------------------------------------------------
           //第二种情况：第一个面没加密，第二个面加密
	  else if( (mesh->Faces[volu->Faces[3]]->Child[0]<0
		     &&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[2]]->Child[2]!=volu->Lines[4])
		  ||(mesh->Faces[volu->Faces[3]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[3]]->Child[2]==volu->Lines[3]
		     &&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[2]]->Child[2]!=volu->Lines[4]  ))

	   //else if(mesh->Faces[volu->Faces[3]]->Child[0]<0&&mesh->Faces[volu->Faces[2]]->Child[0]>=0)
	   {//2
	      //更新第一个面上的边
               mesh->Lines[idx_line]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
	       mesh->Lines[idx_line]->Child[0]=-1;
	       mesh->Lines[idx_line]->Child[1]=-1;
               mesh->Lines[idx_line]->Child[2]=-1;
	       mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	       mesh->Lines[idx_line]->Volus_Owned=NULL;
               mesh->Lines[idx_line]->Mark=-1;
	       mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;
	       mesh->Lines[idx_line++]->Verts[0]=volu->Verts[2];
	       	       
	       //更新第一个面上的新面
               mesh->Faces[volu->Faces[3]]->Verts[0]=volu->Verts[0];
               mesh->Faces[volu->Faces[3]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[volu->Faces[3]]->Verts[2]=volu->Verts[2];
             
	       mesh->Faces[volu->Faces[3]]->Old_Child[0]=mesh->Faces[volu->Faces[3]]->Child[1];
               mesh->Faces[volu->Faces[3]]->Old_Child[1]=mesh->Faces[volu->Faces[3]]->Child[2];
               mesh->Faces[volu->Faces[3]]->Child[0]=volu->Faces[3];
               mesh->Faces[volu->Faces[3]]->Child[1]=idx_face;
               mesh->Faces[volu->Faces[3]]->Child[2]=idx_line-1;

	       mesh->Faces[volu->Faces[3]]->Lines[0]=idx_line-1;
               mesh->Faces[volu->Faces[3]]->Lines[1]=volu->Lines[1];
               mesh->Faces[volu->Faces[3]]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

               mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
               mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;

               mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;

               mesh->Faces[idx_face]->Lines[0]=idx_line-1;
               mesh->Faces[idx_face]->Lines[1]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Faces[idx_face++]->Lines[2]=volu->Lines[3];
	       //更新中间新面的信息
               mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
               mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
              
               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

       	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;

               mesh->Faces[idx_face]->ID_Boundary=-1;

	       mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
               mesh->Faces[idx_face]->Lines[1]=mesh->Faces[volu->Faces[2]]->Child[2];
               mesh->Faces[idx_face++]->Lines[2]=idx_line-1;
          
	       //更新两个单元的信息
               mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
               mesh->Volus[idx_volu]->Verts[1]=volu->Verts[3];
               mesh->Volus[idx_volu]->Verts[2]=volu->Verts[2];
               mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

               mesh->Volus[idx_volu]->Lines[0]=volu->Lines[4];
               mesh->Volus[idx_volu]->Lines[1]=volu->Lines[3];
               mesh->Volus[idx_volu]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
               if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
               mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[2]]->Child[2];
	       else
               mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[2]]->Old_Child[1];
	       mesh->Volus[idx_volu]->Lines[5]=idx_line-1;

	       if(i==0)
	       {
                mesh->Volus[idx_volu]->Father=j;
                mesh->Volus[j]->Father=j;
	       }
	       else
	       mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
               mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;
               mesh->Volus[idx_volu]->Type=1;

               mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
               mesh->Volus[idx_volu]->Faces[1]=idx_face-2;
               if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
	       {
	       mesh->Volus[idx_volu]->Faces[2]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Child[1]:mesh->Faces[volu->Faces[2]]->Child[0];
	       }
	       else
	      {
	       mesh->Volus[idx_volu]->Faces[2]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Old_Child[0]:mesh->Faces[volu->Faces[2]]->Child[0];
	       }
	  
	       mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];

	       mesh->Volus[j]->Verts[0]=volu->Verts[0];
               mesh->Volus[j]->Verts[1]=volu->Verts[2];
               mesh->Volus[j]->Verts[2]=volu->Verts[3];
               mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

	       tmp_line= volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
               mesh->Volus[j]->Lines[0]=volu->Lines[1];
               mesh->Volus[j]->Lines[1]=volu->Lines[2];
               mesh->Volus[j]->Lines[2]=tmp_line;
               mesh->Volus[j]->Lines[3]=volu->Lines[5];
               mesh->Volus[j]->Lines[4]=idx_line-1;
               //mesh->Volus[j]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];
               if(mesh->Faces[volu->Faces[2]]->Old_Child[0]<0)
               mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];
	       else
               mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[2]]->Old_Child[1];

               tmp_face=volu->Faces[1];
	       mesh->Volus[j]->Faces[0]=idx_face-1;
	       if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
	       {
	       mesh->Volus[j]->Faces[1]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Child[1];
               mesh->Volus[j]->Faces[2]=volu->Faces[3];
               mesh->Volus[j]->Faces[3]=tmp_face;
	       }
	       else
	       {
	       mesh->Volus[j]->Faces[1]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Old_Child[0];
               mesh->Volus[j]->Faces[2]=volu->Faces[3];
               mesh->Volus[j]->Faces[3]=tmp_face;
	       }
               mesh->Volus[j]->Type=1;

               mesh->Volus[j]->Child[0]=j;
	       mesh->Volus[j]->Child[1]=idx_volu-1;


	       //ReConstruct(mesh->Volus[idx_volu-1]);
               //ReConstruct(mesh->Volus[idx_volu-2]);
           if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
	      mesh->Volus[j]->Mark=-1; 
	   }
           if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
              mesh->Volus[idx_volu-1]->Mark=1;
	   }
           else
	   mesh->Volus[idx_volu-1]->Mark=-1;

        }//2
         //---------------------------------------------------------------------------------------------
	  else if ( (mesh->Faces[volu->Faces[3]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[3]]->Child[2]!=volu->Lines[3])
		  &&(mesh->Faces[volu->Faces[2]]->Child[0]>=0
		    &&mesh->Faces[volu->Faces[2]]->Child[2]!=volu->Lines[4])
		  ) 
	 
	  //else if(mesh->Faces[volu->Faces[3]]->Child[0]>=0&&mesh->Faces[volu->Faces[2]]->Child[0]>=0)
	  //第三种情况：两个面都加密 
	   {//3
           //更新中间的新面的信息
	      mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
           mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
         
	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
 	   mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;

           mesh->Faces[idx_face]->ID_Boundary=-1;

	   mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
           mesh->Faces[idx_face]->Lines[1]=mesh->Faces[volu->Faces[2]]->Child[2];
           mesh->Faces[idx_face++]->Lines[2]=mesh->Faces[volu->Faces[3]]->Child[2];

           //更新单元信息
	   mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
	   mesh->Volus[idx_volu]->Verts[1]=volu->Verts[3];
	   mesh->Volus[idx_volu]->Verts[2]=volu->Verts[2];
           mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

 	   mesh->Volus[idx_volu]->Lines[0]=volu->Lines[4];
           mesh->Volus[idx_volu]->Lines[1]=volu->Lines[3];
           mesh->Volus[idx_volu]->Lines[2]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
	   mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
	   //mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[2]]->Child[2];
	   //mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[3]]->Child[2];


           if(mesh->Faces[volu->Faces[2]]->Old_Child[0]<0)    
	      mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[2]]->Child[2];
	   else
              mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[2]]->Old_Child[1];

           if(mesh->Faces[volu->Faces[3]]->Old_Child[0]<0)     
	      mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[3]]->Child[2];
	   else
              mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[3]]->Old_Child[1];
           
	   if(i==0)
	   {
            mesh->Volus[idx_volu]->Father=j;
            mesh->Volus[j]->Father=j;
	   }
           else
           mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
           mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;

           mesh->Volus[idx_volu]->Type=1;

	   mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
	   if(mesh->Faces[volu->Faces[3]]->Old_Child[0]<0)
	   mesh->Volus[idx_volu]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Child[1]:mesh->Faces[volu->Faces[3]]->Child[0];
	   else
	   mesh->Volus[idx_volu]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Old_Child[0]:mesh->Faces[volu->Faces[3]]->Child[0];
   
	   if(mesh->Faces[volu->Faces[2]]->Old_Child[0]<0)
	   mesh->Volus[idx_volu]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Child[1]:mesh->Faces[volu->Faces[2]]->Child[0];
	   else
           mesh->Volus[idx_volu]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Old_Child[0]:mesh->Faces[volu->Faces[2]]->Child[0];

	   mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];
           mesh->Volus[j]->Verts[0]=volu->Verts[0];
	   mesh->Volus[j]->Verts[1]=volu->Verts[2];
	   mesh->Volus[j]->Verts[2]=volu->Verts[3];
           mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];
           tmp_line=volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
	   //mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
	   mesh->Volus[j]->Lines[3]=volu->Lines[5];
           //mesh->Volus[j]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];
	   mesh->Volus[j]->Lines[0]=volu->Lines[1];
	   mesh->Volus[j]->Lines[1]=volu->Lines[2];
           mesh->Volus[j]->Lines[2]=tmp_line;
	   
	   if(mesh->Faces[volu->Faces[2]]->Old_Child[0]<0)    
	     mesh->Volus[j]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];
   	   else
             mesh->Volus[j]->Lines[5]=mesh->Faces[volu->Faces[2]]->Old_Child[1];
	   if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)      
	     mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
	   else
             mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Old_Child[1];


	   tmp_face=volu->Faces[1];
	   mesh->Volus[j]->Faces[0]=idx_face-1;
	   if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
	   mesh->Volus[j]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Child[1];
	   else
           mesh->Volus[j]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Old_Child[0];
           if(mesh->Faces[volu->Faces[3]]->Child[1]<0)
	   mesh->Volus[j]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Child[1];
	   else
           mesh->Volus[j]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Old_Child[0];

           mesh->Volus[j]->Faces[3]=tmp_face;



           mesh->Volus[j]->Type=1;

	   mesh->Volus[j]->Child[0]=j;
	   mesh->Volus[j]->Child[1]=idx_volu-1;

 	   if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
	    mesh->Volus[j]->Mark=-1;
	   }
           if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
            mesh->Volus[idx_volu-1]->Mark=1;
	   }
           else
	   mesh->Volus[idx_volu-1]->Mark=-1;

	   }//3
	   //-------------------------------------------------------------------------------------------
           //第四种情况：第一个面(012)加密，第二个面没加密 
	   else
	   {//4
	      //更新第二个面上的边
               mesh->Lines[idx_line]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
	       mesh->Lines[idx_line]->Child[0]=-1;
	       mesh->Lines[idx_line]->Child[1]=-1;
               mesh->Lines[idx_line]->Child[2]=-1;
	       mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	       mesh->Lines[idx_line]->Volus_Owned=NULL;
               mesh->Lines[idx_line]->Mark=-1;
	       mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;
	       mesh->Lines[idx_line++]->Verts[0]=volu->Verts[3];
	       	       
	       //更新第二个面上的新面
               mesh->Faces[volu->Faces[2]]->Verts[0]=volu->Verts[0];
               mesh->Faces[volu->Faces[2]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[volu->Faces[2]]->Verts[2]=volu->Verts[3];
             
               mesh->Faces[volu->Faces[2]]->Old_Child[0]=mesh->Faces[volu->Faces[2]]->Child[1];
               mesh->Faces[volu->Faces[2]]->Old_Child[1]=mesh->Faces[volu->Faces[2]]->Child[2];
               mesh->Faces[volu->Faces[2]]->Child[0]=volu->Faces[2];
               mesh->Faces[volu->Faces[2]]->Child[1]=idx_face;
               mesh->Faces[volu->Faces[2]]->Child[2]=idx_line-1;

	       mesh->Faces[volu->Faces[2]]->Lines[0]=idx_line-1;
               mesh->Faces[volu->Faces[2]]->Lines[1]=volu->Lines[2];
               mesh->Faces[volu->Faces[2]]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

               mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[3];
               mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;

               mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;

               mesh->Faces[idx_face]->Lines[0]=idx_line-1;
               mesh->Faces[idx_face]->Lines[1]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Faces[idx_face++]->Lines[2]=volu->Lines[4];

	       //更新中间新面的信息
               mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
               mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
              
               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;

               mesh->Faces[idx_face]->ID_Boundary=-1;

	       mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
               mesh->Faces[idx_face]->Lines[1]=idx_line-1;
               mesh->Faces[idx_face++]->Lines[2]=mesh->Faces[volu->Faces[3]]->Child[2];

	       //更新两个单元的信息
               mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
               mesh->Volus[idx_volu]->Verts[1]=volu->Verts[3];
               mesh->Volus[idx_volu]->Verts[2]=volu->Verts[2];
               mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

               mesh->Volus[idx_volu]->Lines[0]=volu->Lines[4];
               mesh->Volus[idx_volu]->Lines[1]=volu->Lines[3];
	       mesh->Volus[idx_volu]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               
	       mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
               mesh->Volus[idx_volu]->Lines[4]=idx_line-1;
               if(mesh->Faces[volu->Faces[3]]->Old_Child[0]<0)
	       mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[3]]->Child[2];
               else
               mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[3]]->Old_Child[1];

    	       if(i==0)
   	       {
                mesh->Volus[idx_volu]->Father=j;
                mesh->Volus[j]->Father=j;
	       }
               else
               mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
               mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;

               mesh->Volus[idx_volu]->Type=1;

               mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
               if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
               mesh->Volus[idx_volu]->Faces[1]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Child[1]:mesh->Faces[volu->Faces[3]]->Child[0];
	       else
               mesh->Volus[idx_volu]->Faces[1]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Old_Child[0]:mesh->Faces[volu->Faces[3]]->Child[0];

	       mesh->Volus[idx_volu]->Faces[2]=idx_face-2;
               mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];

	       mesh->Volus[j]->Verts[0]=volu->Verts[0];
               mesh->Volus[j]->Verts[1]=volu->Verts[2];
               mesh->Volus[j]->Verts[2]=volu->Verts[3];
               mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

	       tmp_line= volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
               mesh->Volus[j]->Lines[0]=volu->Lines[1];
               mesh->Volus[j]->Lines[1]=volu->Lines[2];
               mesh->Volus[j]->Lines[2]=tmp_line;
               mesh->Volus[j]->Lines[3]=volu->Lines[5];
	       if(mesh->Faces[volu->Faces[3]]->Old_Child[0]<0)
               mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
	       else
               mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Old_Child[1];

               mesh->Volus[j]->Lines[5]=idx_line-1;

	       tmp_face=volu->Faces[1];
               mesh->Volus[j]->Faces[0]=idx_face-1;
               mesh->Volus[j]->Faces[1]=volu->Faces[2];
	       if( mesh->Faces[volu->Faces[3]]->Old_Child[0]<0)
               mesh->Volus[j]->Faces[2]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Child[1];
               else
               mesh->Volus[j]->Faces[2]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Old_Child[0];

	      
	       mesh->Volus[j]->Faces[3]=tmp_face;

               mesh->Volus[j]->Type=1;

	       mesh->Volus[j]->Child[0]=j;
	       mesh->Volus[j]->Child[1]=idx_volu-1;


	       //ReConstruct(mesh->Volus[idx_volu-1]);
               //ReConstruct(mesh->Volus[idx_volu-2]);
           
	   if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
	     mesh->Volus[j]->Mark=-1;
	   }
           if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
             mesh->Volus[idx_volu-1]->Mark=1;
	   }
           else
	   mesh->Volus[idx_volu-1]->Mark=-1;


        }//4
  
         
         
         
       }//type0
      else if(volu->Type==1)
       {//type1
    if (  (mesh->Faces[volu->Faces[3]]->Child[0]<0&&mesh->Faces[volu->Faces[2]]->Child[0]<0)
	      ||(mesh->Faces[volu->Faces[3]]->Child[0]<0&&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		  &&mesh->Faces[volu->Faces[2]]->Child[2]==volu->Lines[4])
	      ||(mesh->Faces[volu->Faces[2]]->Child[0]<0&&mesh->Faces[volu->Faces[3]]->Child[0]>=0
	         &&mesh->Faces[volu->Faces[3]]->Child[2]==volu->Lines[3] )
	      ||(mesh->Faces[volu->Faces[3]]->Child[0]>=0
		 &&mesh->Faces[volu->Faces[3]]->Child[2]==volu->Lines[3]
		 &&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		 &&mesh->Faces[volu->Faces[2]]->Child[2]==volu->Lines[4])
	     )   

         //if(mesh->Faces[volu->Faces[3]]->Child[0]<0
	  // &&mesh->Faces[volu->Faces[2]]->Child[0]<0)//第一种情况：两个面都没加密 
          {//1
	   //更新面上两条新边的信息 
	   mesh->Lines[idx_line]->Verts[1]= mesh->Lines[volu->Lines[0]]->Child[2];
	   mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	   mesh->Lines[idx_line]->Volus_Owned=NULL;
           mesh->Lines[idx_line]->Mark=-1;
	   mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;
	   mesh->Lines[idx_line]->Child[0]=-1;
	   mesh->Lines[idx_line]->Child[1]=-1;
	   mesh->Lines[idx_line]->Child[2]=-1;
	   mesh->Lines[idx_line++]->Verts[0]=volu->Verts[2];

	   mesh->Lines[idx_line]->Verts[1]= mesh->Lines[volu->Lines[0]]->Child[2];
	   mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	   mesh->Lines[idx_line]->Volus_Owned=NULL;
           mesh->Lines[idx_line]->Mark=-1;
	   mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;
	   mesh->Lines[idx_line]->Child[0]=-1;
	   mesh->Lines[idx_line]->Child[1]=-1;
	   mesh->Lines[idx_line]->Child[2]=-1;
           mesh->Lines[idx_line++]->Verts[0]=volu->Verts[3];
           //更新第一个面上的信息
           mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
           mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

	   mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;

	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
           mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;

           mesh->Faces[idx_face]->Lines[0]=idx_line-2;
           mesh->Faces[idx_face]->Lines[1]=
	   volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
           mesh->Faces[idx_face++]->Lines[2]=volu->Lines[3];

	   mesh->Faces[volu->Faces[3]]->Verts[0]=volu->Verts[0];
           mesh->Faces[volu->Faces[3]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[volu->Faces[3]]->Verts[2]=volu->Verts[2];
        
           mesh->Faces[volu->Faces[3]]->Old_Child[0]=mesh->Faces[volu->Faces[3]]->Child[1];
	   mesh->Faces[volu->Faces[3]]->Old_Child[1]=mesh->Faces[volu->Faces[3]]->Child[2];
	   mesh->Faces[volu->Faces[3]]->Child[0]=volu->Faces[3];
           mesh->Faces[volu->Faces[3]]->Child[1]=idx_face-1;
           mesh->Faces[volu->Faces[3]]->Child[2]=idx_line-2;

	   mesh->Faces[volu->Faces[3]]->Lines[0]=idx_line-2;
           mesh->Faces[volu->Faces[3]]->Lines[1]=volu->Lines[1];
           mesh->Faces[volu->Faces[3]]->Lines[2]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

           //更新第二个面上的信息
           mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[3];
           mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

           mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;

	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
           mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;

           mesh->Faces[idx_face]->Lines[0]=idx_line-1;
           mesh->Faces[idx_face]->Lines[1]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
           mesh->Faces[idx_face++]->Lines[2]=volu->Lines[4];

	   mesh->Faces[volu->Faces[2]]->Verts[0]=volu->Verts[0];
           mesh->Faces[volu->Faces[2]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[volu->Faces[2]]->Verts[2]=volu->Verts[3];
        
           mesh->Faces[volu->Faces[2]]->Old_Child[0]= mesh->Faces[volu->Faces[2]]->Child[1];
           mesh->Faces[volu->Faces[2]]->Old_Child[1]= mesh->Faces[volu->Faces[2]]->Child[2];
	   mesh->Faces[volu->Faces[2]]->Child[0]=volu->Faces[2];
           mesh->Faces[volu->Faces[2]]->Child[1]=idx_face-1;
           mesh->Faces[volu->Faces[2]]->Child[2]=idx_line-1;

	   mesh->Faces[volu->Faces[2]]->Lines[0]=idx_line-1;
           mesh->Faces[volu->Faces[2]]->Lines[1]=volu->Lines[2];
           mesh->Faces[volu->Faces[2]]->Lines[2]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

           //更新中间的新面的信息
	   mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
           mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
	   
	   mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;

	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
         
	   mesh->Faces[idx_face]->ID_Boundary=-1;

	   mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
           mesh->Faces[idx_face]->Lines[1]=idx_line-1;
           mesh->Faces[idx_face++]->Lines[2]=idx_line-2;


	      //更新单元信息
	   mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
	   mesh->Volus[idx_volu]->Verts[1]=volu->Verts[2];
	   mesh->Volus[idx_volu]->Verts[2]=volu->Verts[3];
           mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];
           
	   mesh->Volus[idx_volu]->Lines[0]=volu->Lines[3];
	   mesh->Volus[idx_volu]->Lines[1]=volu->Lines[4];
	   mesh->Volus[idx_volu]->Lines[2]=
	   volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
 	   mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
           mesh->Volus[idx_volu]->Lines[4]=idx_line-2;
 	   mesh->Volus[idx_volu]->Lines[5]=idx_line-1;

	   if(i==0)
   	   {
            mesh->Volus[idx_volu]->Father=j;
            mesh->Volus[j]->Father=j;
           }
           else
           mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
           mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;


           mesh->Volus[idx_volu]->Type=2;

	   mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
	   mesh->Volus[idx_volu]->Faces[1]=idx_face-2;
	   mesh->Volus[idx_volu]->Faces[2]=idx_face-3;
           mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];

	   mesh->Volus[j]->Verts[0]=volu->Verts[0];
	   mesh->Volus[j]->Verts[1]=volu->Verts[2];
	   mesh->Volus[j]->Verts[2]=volu->Verts[3];
	   mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

	   tmp_line=volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
           mesh->Volus[j]->Lines[0]=volu->Lines[1];
	   mesh->Volus[j]->Lines[1]=volu->Lines[2];
	   mesh->Volus[j]->Lines[2]=tmp_line;
 	   mesh->Volus[j]->Lines[3]=volu->Lines[5];
           mesh->Volus[j]->Lines[4]=idx_line-2;
 	   mesh->Volus[j]->Lines[5]=idx_line-1;

	   tmp_face=volu->Faces[1];
	   mesh->Volus[j]->Faces[0]=idx_face-1;
	   mesh->Volus[j]->Faces[1]=volu->Faces[2];
	   mesh->Volus[j]->Faces[2]=volu->Faces[3];
	   mesh->Volus[j]->Faces[3]=tmp_face;

           mesh->Volus[j]->Type=2;

	   mesh->Volus[j]->Child[0]=j;
	   mesh->Volus[j]->Child[1]=idx_volu-1;

           //ReConstruct(mesh->Volus[idx_volu-1]);
           //ReConstruct(mesh->Volus[MarkSet[i]]);
          if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
            mesh->Volus[j]->Mark=-1;
	   }
          if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
            mesh->Volus[idx_volu-1]->Mark=1;
	   }
          else
	   mesh->Volus[idx_volu-1]->Mark=-1;


      }//1
           //-----------------------------------------------------------------------------------
           //第二种情况：第一个面没加密，第二个面加密 
	  
else if( (mesh->Faces[volu->Faces[3]]->Child[0]<0
		     &&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[2]]->Child[2]!=volu->Lines[4])
		  ||(mesh->Faces[volu->Faces[3]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[3]]->Child[2]==volu->Lines[3]
		     &&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[2]]->Child[2]!=volu->Lines[4]  )
      ) 
	 // else if(mesh->Faces[volu->Faces[3]]->Child[0]<0&&mesh->Faces[volu->Faces[2]]->Child[0]>=0)
	   {//2
	      //更新第一个面上的边	   
               mesh->Lines[idx_line]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
	       mesh->Lines[idx_line]->Child[0]=-1;
	       mesh->Lines[idx_line]->Child[1]=-1;
               mesh->Lines[idx_line]->Child[2]=-1;
	       mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	       mesh->Lines[idx_line]->Volus_Owned=NULL;
               mesh->Lines[idx_line]->Mark=-1;
	       mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;
	       mesh->Lines[idx_line++]->Verts[0]=volu->Verts[2];
	       	       
	       //更新第一个面上的新面
               mesh->Faces[volu->Faces[3]]->Verts[0]=volu->Verts[0];
               mesh->Faces[volu->Faces[3]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[volu->Faces[3]]->Verts[2]=volu->Verts[2];
            
	       mesh->Faces[volu->Faces[3]]->Old_Child[0]=mesh->Faces[volu->Faces[3]]->Child[1];
               mesh->Faces[volu->Faces[3]]->Old_Child[1]=mesh->Faces[volu->Faces[3]]->Child[2];
  
               mesh->Faces[volu->Faces[3]]->Child[0]=volu->Faces[3];
               mesh->Faces[volu->Faces[3]]->Child[1]=idx_face;
               mesh->Faces[volu->Faces[3]]->Child[2]=idx_line-1;

	       mesh->Faces[volu->Faces[3]]->Lines[0]=idx_line-1;
               mesh->Faces[volu->Faces[3]]->Lines[1]=volu->Lines[1];
               mesh->Faces[volu->Faces[3]]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

               mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
               mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;

               mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;

               mesh->Faces[idx_face]->Lines[0]=idx_line-1;
               mesh->Faces[idx_face]->Lines[1]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Faces[idx_face++]->Lines[2]=volu->Lines[3];

	       //更新中间新面的信息
               mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
               mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
              
               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;

               mesh->Faces[idx_face]->ID_Boundary=-1;

	       mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
               mesh->Faces[idx_face]->Lines[1]=mesh->Faces[volu->Faces[2]]->Child[2];
               mesh->Faces[idx_face++]->Lines[2]=idx_line-1;
          
	       //更新两个单元的信息
               mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
               mesh->Volus[idx_volu]->Verts[1]=volu->Verts[2];
               mesh->Volus[idx_volu]->Verts[2]=volu->Verts[3];
               mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

               mesh->Volus[idx_volu]->Lines[0]=volu->Lines[3];
               mesh->Volus[idx_volu]->Lines[1]=volu->Lines[4];
               mesh->Volus[idx_volu]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
               if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
	       mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];
	       else
               mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[2]]->Old_Child[1];
               mesh->Volus[idx_volu]->Lines[4]=idx_line-1;

               if(i==0)
   	       {
                mesh->Volus[idx_volu]->Father=j;
                mesh->Volus[j]->Father=j;
               }
               else
               mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
               mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;


               mesh->Volus[idx_volu]->Type=2;

               mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
               mesh->Volus[idx_volu]->Faces[2]=idx_face-2;
	       if( mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
               mesh->Volus[idx_volu]->Faces[1]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Child[1]:mesh->Faces[volu->Faces[2]]->Child[0];
	       else
	       mesh->Volus[idx_volu]->Faces[1]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Old_Child[0]:mesh->Faces[volu->Faces[2]]->Child[0];
  
	       mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];

	       mesh->Volus[j]->Verts[0]=volu->Verts[0];
               mesh->Volus[j]->Verts[1]=volu->Verts[2];
               mesh->Volus[j]->Verts[2]=volu->Verts[3];
               mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

	       tmp_line=volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
               mesh->Volus[j]->Lines[0]=volu->Lines[1];
               mesh->Volus[j]->Lines[1]=volu->Lines[2];
               mesh->Volus[j]->Lines[2]=tmp_line;
               mesh->Volus[j]->Lines[3]=volu->Lines[5];
               mesh->Volus[j]->Lines[4]=idx_line-1;
	       if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
               mesh->Volus[j]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];
	       else
               mesh->Volus[j]->Lines[5]=mesh->Faces[volu->Faces[2]]->Old_Child[1];


	       tmp_face=volu->Faces[1];
               mesh->Volus[j]->Faces[0]=idx_face-1;
	       if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
               mesh->Volus[j]->Faces[1]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Child[1];
	       else
	       mesh->Volus[j]->Faces[1]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Old_Child[0];

	       mesh->Volus[j]->Faces[2]=volu->Faces[3];
               mesh->Volus[j]->Faces[3]=tmp_face;

               mesh->Volus[j]->Type=2;


               mesh->Volus[j]->Child[0]=j;
	       mesh->Volus[j]->Child[1]=idx_volu-1;


	       //ReConstruct(mesh->Volus[idx_volu-1]);
               //ReConstruct(mesh->Volus[idx_volu-2]);
           if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
	      mesh->Volus[j]->Mark=-1; 
	   }
           if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
              mesh->Volus[idx_volu-1]->Mark=1;
	   }
            else
	   mesh->Volus[idx_volu-1]->Mark=-1;


        }//2
         //---------------------------------------------------------------------------------------------
	  
	    else if ( (mesh->Faces[volu->Faces[3]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[3]]->Child[2]!=volu->Lines[3])
		  &&(mesh->Faces[volu->Faces[2]]->Child[0]>=0
		    &&mesh->Faces[volu->Faces[2]]->Child[2]!=volu->Lines[4])
		  ) 
	
	 // else if(mesh->Faces[volu->Faces[3]]->Child[0]>=0&&mesh->Faces[volu->Faces[2]]->Child[0]>=0)//第三种情况：两个面都加密 
	   {//3
           //更新中间的新面的信息
           mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
           mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
         
	   mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;

	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
 
           mesh->Faces[idx_face]->ID_Boundary=-1;

	   mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
           mesh->Faces[idx_face]->Lines[1]=mesh->Faces[volu->Faces[2]]->Child[2];
           mesh->Faces[idx_face++]->Lines[2]=mesh->Faces[volu->Faces[3]]->Child[2];


           //更新单元信息
	   mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
	   mesh->Volus[idx_volu]->Verts[1]=volu->Verts[2];
	   mesh->Volus[idx_volu]->Verts[2]=volu->Verts[3];
           mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

 	   mesh->Volus[idx_volu]->Lines[0]=volu->Lines[3];
           mesh->Volus[idx_volu]->Lines[1]=volu->Lines[4];
           mesh->Volus[idx_volu]->Lines[2]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
	   mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
	   if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
	   mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];
	   else
	   mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[2]]->Old_Child[1];
           if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
	   mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
           else
           mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[3]]->Old_Child[1];
          
	   if(i==0)
   	       {
                mesh->Volus[idx_volu]->Father=j;
                mesh->Volus[j]->Father=j;
               }
           else
           mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
           mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;


           mesh->Volus[idx_volu]->Type=2;

	   mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
	   if(mesh->Faces[volu->Faces[3]]->Old_Child[0]<0)
	   mesh->Volus[idx_volu]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Child[1]:mesh->Faces[volu->Faces[3]]->Child[0];
	   else
           mesh->Volus[idx_volu]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Old_Child[0]:mesh->Faces[volu->Faces[3]]->Child[0];
	   if(mesh->Faces[volu->Faces[2]]->Old_Child[0]<0)
	   mesh->Volus[idx_volu]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Child[1]:mesh->Faces[volu->Faces[2]]->Child[0];
	   else
	   mesh->Volus[idx_volu]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Old_Child[0]:mesh->Faces[volu->Faces[2]]->Child[0];

	   mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];

           mesh->Volus[j]->Verts[0]=volu->Verts[0];
	   mesh->Volus[j]->Verts[1]=volu->Verts[2];
	   mesh->Volus[j]->Verts[2]=volu->Verts[3];
           mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

	   tmp_line=volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
	   mesh->Volus[j]->Lines[0]=volu->Lines[1];
	   mesh->Volus[j]->Lines[1]=volu->Lines[2];
           mesh->Volus[j]->Lines[2]=tmp_line;
	   mesh->Volus[j]->Lines[3]=volu->Lines[5];
           if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
	   mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
	   else
   	   mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Old_Child[1];
	   if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
           mesh->Volus[j]->Lines[5]=mesh->Faces[volu->Faces[2]]->Old_Child[1];

	   tmp_face=volu->Faces[1];
	   mesh->Volus[j]->Faces[0]=idx_face-1;
	   if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
	   mesh->Volus[j]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Child[1];
	   else
	   mesh->Volus[j]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Old_Child[0];
           if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
	   mesh->Volus[j]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Child[1];
	   else
	   mesh->Volus[j]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Old_Child[0];

	   mesh->Volus[j]->Faces[3]=tmp_face;

           mesh->Volus[j]->Type=2;

	   mesh->Volus[j]->Child[0]=j;
	   mesh->Volus[j]->Child[1]=idx_volu-1;


           //ReConstruct(mesh->Volus[idx_volu-1]);
           //ReConstruct(mesh->Volus[idx_volu-2]);
 	   if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
	    mesh->Volus[j]->Mark=-1;
	   }
           if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
            mesh->Volus[idx_volu-1]->Mark=1;
	   }
          else
	   mesh->Volus[idx_volu-1]->Mark=-1;


	   }//3
	   //-------------------------------------------------------------------------------------------
           //第四种情况：第一个面(012)加密，第二个面没加密 
	   else
	   {//4
	      //更新第二个面上的边	   
               mesh->Lines[idx_line]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
	       mesh->Lines[idx_line]->Child[0]=-1;
	       mesh->Lines[idx_line]->Child[1]=-1;
               mesh->Lines[idx_line]->Child[2]=-1;
	       mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	       mesh->Lines[idx_line]->Volus_Owned=NULL;
               mesh->Lines[idx_line]->Mark=-1;
	       mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;
	       mesh->Lines[idx_line++]->Verts[0]=volu->Verts[3];
	       	       
	       //更新第二个面上的新面
               mesh->Faces[volu->Faces[2]]->Verts[0]=volu->Verts[0];
               mesh->Faces[volu->Faces[2]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[volu->Faces[2]]->Verts[2]=volu->Verts[3];
              
	       mesh->Faces[volu->Faces[2]]->Lines[0]=idx_line-1;
               mesh->Faces[volu->Faces[2]]->Lines[1]=volu->Lines[2];
               mesh->Faces[volu->Faces[2]]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

               mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[3];
               mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;

               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

               mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;

               mesh->Faces[idx_face]->Lines[0]=idx_line-1;
               mesh->Faces[idx_face]->Lines[1]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Faces[idx_face++]->Lines[2]=volu->Lines[4];

	       mesh->Faces[volu->Faces[2]]->Old_Child[0]=mesh->Faces[volu->Faces[2]]->Child[1];
	       mesh->Faces[volu->Faces[2]]->Old_Child[1]=mesh->Faces[volu->Faces[2]]->Child[2];

	       mesh->Faces[volu->Faces[2]]->Child[0]=volu->Faces[2];
	       mesh->Faces[volu->Faces[2]]->Child[1]=idx_face-1;
	       mesh->Faces[volu->Faces[2]]->Child[2]=idx_line-1;
	      
	       //更新中间新面的信息
               mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
               mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
              
	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;

               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

               mesh->Faces[idx_face]->ID_Boundary=-1;

	       mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
               mesh->Faces[idx_face]->Lines[1]=idx_line-1;
               mesh->Faces[idx_face++]->Lines[2]=mesh->Faces[volu->Faces[3]]->Child[2];

	       //更新两个单元的信息
               mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
               mesh->Volus[idx_volu]->Verts[1]=volu->Verts[2];
               mesh->Volus[idx_volu]->Verts[2]=volu->Verts[3];
               mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

               mesh->Volus[idx_volu]->Lines[0]=volu->Lines[3];
               mesh->Volus[idx_volu]->Lines[1]=volu->Lines[4];
               mesh->Volus[idx_volu]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
               mesh->Volus[idx_volu]->Lines[5]=idx_line-1;
	       if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
               mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
               else
               mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[3]]->Old_Child[1];

	       if(i==0)
   	       {
                mesh->Volus[idx_volu]->Father=j;
                mesh->Volus[j]->Father=j;
               }
               else
               mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
               mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;

               mesh->Volus[idx_volu]->Type=2;

               mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
	       if(mesh->Faces[volu->Faces[3]]->Old_Child[0]<0)
               mesh->Volus[idx_volu]->Faces[2]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Child[1]:mesh->Faces[volu->Faces[3]]->Child[0];
	       else
	       mesh->Volus[idx_volu]->Faces[2]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Old_Child[0]:mesh->Faces[volu->Faces[3]]->Child[0];

               mesh->Volus[idx_volu]->Faces[1]=idx_face-2;
               mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];

	       mesh->Volus[j]->Verts[0]=volu->Verts[0];
               mesh->Volus[j]->Verts[1]=volu->Verts[2];
               mesh->Volus[j]->Verts[2]=volu->Verts[3];
               mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

	       tmp_line=volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
               mesh->Volus[j]->Lines[0]=volu->Lines[1];
               mesh->Volus[j]->Lines[1]=volu->Lines[2];
               mesh->Volus[j]->Lines[2]=tmp_line;
               mesh->Volus[j]->Lines[3]=volu->Lines[5];
	       if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
               mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
               else
               mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Old_Child[1];

               mesh->Volus[j]->Lines[5]=idx_line-1;

	       tmp_face=volu->Faces[1];
               mesh->Volus[j]->Faces[0]=idx_face-1;
               mesh->Volus[j]->Faces[1]=volu->Faces[2];
	       if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
               mesh->Volus[j]->Faces[2]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Child[1];
	       else
               mesh->Volus[j]->Faces[2]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Old_Child[0];

	       mesh->Volus[j]->Faces[3]=tmp_face;

               mesh->Volus[j]->Type=2;

	       mesh->Volus[j]->Child[0]=j;
	       mesh->Volus[j]->Child[1]=idx_volu-1;


	       //ReConstruct(mesh->Volus[idx_volu-1]);
               //ReConstruct(mesh->Volus[idx_volu-2]);
           
	   if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
	     mesh->Volus[j]->Mark=-1;
	   }
           if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
             mesh->Volus[idx_volu-1]->Mark=1;
	   }
          else
	   mesh->Volus[idx_volu-1]->Mark=-1;


        }//4
  
        

       }//type1
      else 
       {//type2
if (  (mesh->Faces[volu->Faces[3]]->Child[0]<0&&mesh->Faces[volu->Faces[2]]->Child[0]<0)
	      ||(mesh->Faces[volu->Faces[3]]->Child[0]<0&&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		  &&mesh->Faces[volu->Faces[2]]->Child[2]==volu->Lines[4])
	      ||(mesh->Faces[volu->Faces[2]]->Child[0]<0&&mesh->Faces[volu->Faces[3]]->Child[0]>=0
	         &&mesh->Faces[volu->Faces[3]]->Child[2]==volu->Lines[3] )
	      ||(mesh->Faces[volu->Faces[3]]->Child[0]>=0
		 &&mesh->Faces[volu->Faces[3]]->Child[2]==volu->Lines[3]
		 &&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		 &&mesh->Faces[volu->Faces[2]]->Child[2]==volu->Lines[4])
	     )  
	//  if(mesh->Faces[volu->Faces[3]]->Child[0]<0
	  // &&mesh->Faces[volu->Faces[2]]->Child[0]<0)//第一种情况：两个面都没加密 
          {//1
	   //更新面上两条新边的信息 
	   mesh->Lines[idx_line]->Verts[1]= mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Lines[idx_line]->Mark=-1;
	   mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	   mesh->Lines[idx_line]->Volus_Owned=NULL;
           mesh->Lines[idx_line]->Child[0]=-1;
	   mesh->Lines[idx_line]->Child[1]=-1;
	   mesh->Lines[idx_line]->Child[2]=-1;
	   mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;
	   mesh->Lines[idx_line++]->Verts[0]=volu->Verts[2];

	   mesh->Lines[idx_line]->Verts[1]= mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Lines[idx_line]->Mark=-1;
	   mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	   mesh->Lines[idx_line]->Volus_Owned=NULL;
	   mesh->Lines[idx_line]->Child[0]=-1;
	   mesh->Lines[idx_line]->Child[1]=-1;
	   mesh->Lines[idx_line]->Child[2]=-1;
           mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;
	   mesh->Lines[idx_line++]->Verts[0]=volu->Verts[3];
           //更新第一个面上的信息
           mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
           mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

	   mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;

	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
           mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;

           mesh->Faces[idx_face]->Lines[0]=idx_line-2;
           mesh->Faces[idx_face]->Lines[1]=
	   volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
           mesh->Faces[idx_face++]->Lines[2]=volu->Lines[3];

	   mesh->Faces[volu->Faces[3]]->Verts[0]=volu->Verts[0];
           mesh->Faces[volu->Faces[3]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[volu->Faces[3]]->Verts[2]=volu->Verts[2];
         
	   mesh->Faces[volu->Faces[3]]->Lines[0]=idx_line-2;
           mesh->Faces[volu->Faces[3]]->Lines[1]=volu->Lines[1];
           mesh->Faces[volu->Faces[3]]->Lines[2]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
           
	   mesh->Faces[volu->Faces[3]]->Old_Child[0]=mesh->Faces[volu->Faces[3]]->Child[1];
	   mesh->Faces[volu->Faces[3]]->Old_Child[1]=mesh->Faces[volu->Faces[3]]->Child[2];
	   mesh->Faces[volu->Faces[3]]->Child[0]=volu->Faces[3];
           mesh->Faces[volu->Faces[3]]->Child[1]=idx_face-1;
           mesh->Faces[volu->Faces[3]]->Child[2]=idx_line-2;

           //更新第二个面上的信息
           mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[3];
           mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

           mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;

	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
           mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;

           mesh->Faces[idx_face]->Lines[0]=idx_line-1;
           mesh->Faces[idx_face]->Lines[1]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
           mesh->Faces[idx_face++]->Lines[2]=volu->Lines[4];

	   mesh->Faces[volu->Faces[2]]->Verts[0]=volu->Verts[0];
           mesh->Faces[volu->Faces[2]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[volu->Faces[2]]->Verts[2]=volu->Verts[3];
         

	   mesh->Faces[volu->Faces[2]]->Lines[0]=idx_line-1;
           mesh->Faces[volu->Faces[2]]->Lines[1]=volu->Lines[2];
           mesh->Faces[volu->Faces[2]]->Lines[2]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

	   mesh->Faces[volu->Faces[2]]->Old_Child[0]=mesh->Faces[volu->Faces[2]]->Child[1];
           mesh->Faces[volu->Faces[2]]->Old_Child[1]=mesh->Faces[volu->Faces[2]]->Child[2];

	   mesh->Faces[volu->Faces[2]]->Child[0]=volu->Faces[2];
           mesh->Faces[volu->Faces[2]]->Child[1]=idx_face-1;
           mesh->Faces[volu->Faces[2]]->Child[2]=idx_line-1;


           //更新中间的新面的信息
	   mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
           mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
         
	   mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;

	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
         
	   mesh->Faces[idx_face]->ID_Boundary=-1;

	   mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
           mesh->Faces[idx_face]->Lines[1]=idx_line-1;
           mesh->Faces[idx_face++]->Lines[2]=idx_line-2;


	      //更新单元信息
	   mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
	   mesh->Volus[idx_volu]->Verts[1]=volu->Verts[2];
	   mesh->Volus[idx_volu]->Verts[2]=volu->Verts[3];
           mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];
           
	   mesh->Volus[idx_volu]->Lines[0]=volu->Lines[3];
	   mesh->Volus[idx_volu]->Lines[1]=volu->Lines[4];
	   mesh->Volus[idx_volu]->Lines[2]=
	   volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
 	   mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
           mesh->Volus[idx_volu]->Lines[4]=idx_line-2;
 	   mesh->Volus[idx_volu]->Lines[5]=idx_line-1;

	   if(i==0)
   	       {
                mesh->Volus[idx_volu]->Father=j;
                mesh->Volus[j]->Father=j;
               }
           else
           mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
           mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;


           mesh->Volus[idx_volu]->Type=0;

	   mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
	   mesh->Volus[idx_volu]->Faces[1]=idx_face-2;
	   mesh->Volus[idx_volu]->Faces[2]=idx_face-3;
           mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];

	   mesh->Volus[j]->Verts[0]=volu->Verts[0];
	   mesh->Volus[j]->Verts[1]=volu->Verts[2];
	   mesh->Volus[j]->Verts[2]=volu->Verts[3];
	   mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

	   tmp_line=volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
           mesh->Volus[j]->Lines[0]=volu->Lines[1];
	   mesh->Volus[j]->Lines[1]=volu->Lines[2];
	   mesh->Volus[j]->Lines[2]=tmp_line;
 	   mesh->Volus[j]->Lines[3]=volu->Lines[5];
           mesh->Volus[j]->Lines[4]=idx_line-2;
 	   mesh->Volus[j]->Lines[5]=idx_line-1;

	   tmp_face=volu->Faces[1];
	   mesh->Volus[j]->Faces[0]=idx_face-1;
	   mesh->Volus[j]->Faces[1]=volu->Faces[2];
	   mesh->Volus[j]->Faces[2]=volu->Faces[3];
	   mesh->Volus[j]->Faces[3]=tmp_face;

           mesh->Volus[j]->Type=0;

	   mesh->Volus[j]->Child[0]=j;
	   mesh->Volus[j]->Child[1]=idx_volu-1;

           //ReConstruct(mesh->Volus[idx_volu-1]);
           //ReConstruct(mesh->Volus[MarkSet[i]]);
          if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
            mesh->Volus[j]->Mark=-1;
	   }
          if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
            mesh->Volus[idx_volu-1]->Mark=1;
	   }
          else
	   mesh->Volus[idx_volu-1]->Mark=-1;


      }//1
           //-----------------------------------------------------------------------------------
           //第二种情况：第一个面没加密，第二个面加密 
   else if( (mesh->Faces[volu->Faces[3]]->Child[0]<0
		     &&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[2]]->Child[2]!=volu->Lines[4])
		  ||(mesh->Faces[volu->Faces[3]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[3]]->Child[2]==volu->Lines[3]
		     &&mesh->Faces[volu->Faces[2]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[2]]->Child[2]!=volu->Lines[4]  ))

 
	// else if(mesh->Faces[volu->Faces[3]]->Child[0]<0&&mesh->Faces[volu->Faces[2]]->Child[0]>=0)
	   {//2
	      //更新第一个面上的边	   
	      mesh->Lines[idx_line]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
	       mesh->Lines[idx_line]->Child[0]=-1;
	       mesh->Lines[idx_line]->Child[1]=-1;
               mesh->Lines[idx_line]->Child[2]=-1;
	       mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	       mesh->Lines[idx_line]->Volus_Owned=NULL;
               mesh->Lines[idx_line]->Mark=-1;
	       mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;
	       mesh->Lines[idx_line++]->Verts[0]=volu->Verts[2];
	       	       
	       //更新第一个面上的新面
               mesh->Faces[volu->Faces[3]]->Verts[0]=volu->Verts[0];
               mesh->Faces[volu->Faces[3]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[volu->Faces[3]]->Verts[2]=volu->Verts[2];
              
	       mesh->Faces[volu->Faces[3]]->Lines[0]=idx_line-1;
               mesh->Faces[volu->Faces[3]]->Lines[1]=volu->Lines[1];
               mesh->Faces[volu->Faces[3]]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

               mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
               mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;

               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

               mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[3]]->ID_Boundary;

               mesh->Faces[idx_face]->Lines[0]=idx_line-1;
               mesh->Faces[idx_face]->Lines[1]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Faces[idx_face++]->Lines[2]=volu->Lines[3];

	       mesh->Faces[volu->Faces[3]]->Old_Child[0]=mesh->Faces[volu->Faces[3]]->Child[1];
	       mesh->Faces[volu->Faces[3]]->Old_Child[1]=mesh->Faces[volu->Faces[3]]->Child[2];
	       mesh->Faces[volu->Faces[3]]->Child[0]=volu->Faces[3];
	       mesh->Faces[volu->Faces[3]]->Child[1]=idx_face-1;
	       mesh->Faces[volu->Faces[3]]->Child[2]=idx_line-1;
	      
	       //更新中间新面的信息
               mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
               mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
             
	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;
 
               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

               mesh->Faces[idx_face]->ID_Boundary=-1;

	       mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
               mesh->Faces[idx_face]->Lines[1]=mesh->Faces[volu->Faces[2]]->Child[2];
               mesh->Faces[idx_face++]->Lines[2]=idx_line-1;
          
	       //更新两个单元的信息
               mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
               mesh->Volus[idx_volu]->Verts[1]=volu->Verts[2];
               mesh->Volus[idx_volu]->Verts[2]=volu->Verts[3];
               mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

               mesh->Volus[idx_volu]->Lines[0]=volu->Lines[3];
               mesh->Volus[idx_volu]->Lines[1]=volu->Lines[4];
               mesh->Volus[idx_volu]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
	       if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
               mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];
	       else
               mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[2]]->Old_Child[1];
	       mesh->Volus[idx_volu]->Lines[4]=idx_line-1;

	       if(i==0)
   	       {
                mesh->Volus[idx_volu]->Father=j;
                mesh->Volus[j]->Father=j;
               }
               else
               mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
               mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;

               mesh->Volus[idx_volu]->Type=0;

               mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
               mesh->Volus[idx_volu]->Faces[2]=idx_face-2;
	       if(mesh->Faces[volu->Faces[2]]->Old_Child[0]<0)
               mesh->Volus[idx_volu]->Faces[1]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Child[1]:mesh->Faces[volu->Faces[2]]->Child[0];
	       else
	        mesh->Volus[idx_volu]->Faces[1]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Old_Child[0]:mesh->Faces[volu->Faces[2]]->Child[0];

	       mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];

	       mesh->Volus[j]->Verts[0]=volu->Verts[0];
               mesh->Volus[j]->Verts[1]=volu->Verts[2];
               mesh->Volus[j]->Verts[2]=volu->Verts[3];
               mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

	       tmp_line=volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
               mesh->Volus[j]->Lines[0]=volu->Lines[1];
               mesh->Volus[j]->Lines[1]=volu->Lines[2];
               mesh->Volus[j]->Lines[2]=tmp_line;
               mesh->Volus[j]->Lines[3]=volu->Lines[5];
               mesh->Volus[j]->Lines[4]=idx_line-1;
	       if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
               mesh->Volus[j]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];
	       else
                mesh->Volus[j]->Lines[5]=mesh->Faces[volu->Faces[2]]->Old_Child[1];

	       tmp_face=volu->Faces[1];
               mesh->Volus[j]->Faces[0]=idx_face-1;
	       if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
               mesh->Volus[j]->Faces[1]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Child[1];
	       else
	       mesh->Volus[j]->Faces[1]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Old_Child[0];

	       mesh->Volus[j]->Faces[2]=volu->Faces[3];
               mesh->Volus[j]->Faces[3]=tmp_face;

               mesh->Volus[j]->Type=0;

               mesh->Volus[j]->Child[0]=j;
	       mesh->Volus[j]->Child[1]=idx_volu-1;


	       //ReConstruct(mesh->Volus[idx_volu-1]);
               //ReConstruct(mesh->Volus[idx_volu-2]);
           if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
	      mesh->Volus[j]->Mark=-1; 
	   }
           if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
              mesh->Volus[idx_volu-1]->Mark=1;
	   }
          else
	   mesh->Volus[idx_volu-1]->Mark=-1;


        }//2
         //---------------------------------------------------------------------------------------------
	    else if ( (mesh->Faces[volu->Faces[3]]->Child[0]>=0
		     &&mesh->Faces[volu->Faces[3]]->Child[2]!=volu->Lines[3])
		  &&(mesh->Faces[volu->Faces[2]]->Child[0]>=0
		    &&mesh->Faces[volu->Faces[2]]->Child[2]!=volu->Lines[4])
		  ) 

	 //else if(mesh->Faces[volu->Faces[3]]->Child[0]>=0&&mesh->Faces[volu->Faces[2]]->Child[0]>=0)//第三种情况：两个面都加密 
	   {//3
           
	    //更新中间的新面的信息
	   mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
           mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
           mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
        
	   mesh->Faces[idx_face]->Old_Child[0]=-1;
           mesh->Faces[idx_face]->Old_Child[1]=-1;
 
	   mesh->Faces[idx_face]->Child[0]=-1;
           mesh->Faces[idx_face]->Child[1]=-1;
           mesh->Faces[idx_face]->Child[2]=-1;
 
           mesh->Faces[idx_face]->ID_Boundary=-1;

	   mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
           mesh->Faces[idx_face]->Lines[1]=mesh->Faces[volu->Faces[2]]->Child[2];
           mesh->Faces[idx_face++]->Lines[2]=mesh->Faces[volu->Faces[3]]->Child[2];


           //更新单元信息
 	   mesh->Volus[idx_volu]->Lines[0]=volu->Lines[3];
           mesh->Volus[idx_volu]->Lines[1]=volu->Lines[4];
           mesh->Volus[idx_volu]->Lines[2]=
           volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
	   mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
	   if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
	   mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];
	   else
           mesh->Volus[idx_volu]->Lines[5]=mesh->Faces[volu->Faces[2]]->Old_Child[1];
           if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
            mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
	   else
	   mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[3]]->Old_Child[1];

	   if(i==0)
   	       {
                mesh->Volus[idx_volu]->Father=j;
                mesh->Volus[j]->Father=j;
               }
           else
           mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
           mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;

           mesh->Volus[idx_volu]->Type=0;

	   mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
	   if(mesh->Faces[volu->Faces[3]]->Old_Child[0]<0)
	   mesh->Volus[idx_volu]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Child[1]:mesh->Faces[volu->Faces[3]]->Child[0];
	   else
	   mesh->Volus[idx_volu]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Old_Child[0]:mesh->Faces[volu->Faces[3]]->Child[0];
	   if(mesh->Faces[volu->Faces[2]]->Old_Child[0]<0)
	   mesh->Volus[idx_volu]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Child[1]:mesh->Faces[volu->Faces[2]]->Child[0];
	   else
           mesh->Volus[idx_volu]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Old_Child[0]:mesh->Faces[volu->Faces[2]]->Child[0];

	   
	   mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];

	   
           mesh->Volus[j]->Verts[0]=volu->Verts[0];
	   mesh->Volus[j]->Verts[1]=volu->Verts[2];
	   mesh->Volus[j]->Verts[2]=volu->Verts[3];
           mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

	   tmp_line=volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	   mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
	   mesh->Volus[j]->Lines[0]=volu->Lines[1];
	   mesh->Volus[j]->Lines[1]=volu->Lines[2];
           mesh->Volus[j]->Lines[2]=tmp_line;
	   mesh->Volus[j]->Lines[3]=volu->Lines[5];
           mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
           mesh->Volus[j]->Lines[5]=mesh->Faces[volu->Faces[2]]->Child[2];

	   tmp_face=volu->Faces[1];
	   mesh->Volus[j]->Faces[0]=idx_face-1;
	   if(mesh->Faces[volu->Faces[2]]->Old_Child[1]<0)
	   mesh->Volus[j]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Child[1];
	   else
           mesh->Volus[j]->Faces[1]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[2]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[2]]->Child[0]:mesh->Faces[volu->Faces[2]]->Old_Child[0];
           if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
	   mesh->Volus[j]->Faces[2]=
           volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	   mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Old_Child[0];
           mesh->Volus[j]->Faces[3]=tmp_face;

           mesh->Volus[j]->Type=0;

	   mesh->Volus[j]->Child[0]=j;
	   mesh->Volus[j]->Child[1]=idx_volu-1;


           //ReConstruct(mesh->Volus[idx_volu-1]);
           //ReConstruct(mesh->Volus[idx_volu-2]);
 	   if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
	    mesh->Volus[j]->Mark=-1;
	   }
           if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
            mesh->Volus[idx_volu-1]->Mark=1;
	   }
          else
	   mesh->Volus[idx_volu-1]->Mark=-1;


	   }//3
	   //-------------------------------------------------------------------------------------------
           //第四种情况：第一个面(012)加密，第二个面没加密 
	   else
	   {//4
	      //更新第二个面上的边	   
	      mesh->Lines[idx_line]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
	       mesh->Lines[idx_line]->Child[0]=-1;
	       mesh->Lines[idx_line]->Child[1]=-1;
               mesh->Lines[idx_line]->Child[2]=-1;
	       mesh->Lines[idx_line]->Num_Volus_Owned=-1;
	       mesh->Lines[idx_line]->Volus_Owned=NULL;
               mesh->Lines[idx_line]->Mark=-1;
	       mesh->Lines[idx_line]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;
	       mesh->Lines[idx_line++]->Verts[0]=volu->Verts[3];
	       	       
	       //更新第二个面上的新面
               mesh->Faces[volu->Faces[2]]->Verts[0]=volu->Verts[0];
               mesh->Faces[volu->Faces[2]]->Verts[1]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[volu->Faces[2]]->Verts[2]=volu->Verts[3];
              
	       mesh->Faces[volu->Faces[2]]->Lines[0]=idx_line-1;
               mesh->Faces[volu->Faces[2]]->Lines[1]=volu->Lines[2];
               mesh->Faces[volu->Faces[2]]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];

               mesh->Faces[idx_face]->Verts[0]=volu->Verts[1];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[3];
               mesh->Faces[idx_face]->Verts[2]=mesh->Lines[volu->Lines[0]]->Child[2];

	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;

               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

               mesh->Faces[idx_face]->ID_Boundary=mesh->Faces[volu->Faces[2]]->ID_Boundary;

               mesh->Faces[idx_face]->Lines[0]=idx_line-1;
               mesh->Faces[idx_face]->Lines[1]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Faces[idx_face++]->Lines[2]=volu->Lines[4];

	       mesh->Faces[volu->Faces[2]]->Old_Child[0]=mesh->Faces[volu->Faces[2]]->Child[1];
	       mesh->Faces[volu->Faces[2]]->Old_Child[1]=mesh->Faces[volu->Faces[2]]->Child[2];

	       mesh->Faces[volu->Faces[2]]->Child[0]=volu->Faces[2];
	       mesh->Faces[volu->Faces[2]]->Child[1]=idx_face-1;
	       mesh->Faces[volu->Faces[2]]->Child[2]=idx_line-1;
	      
	       //更新中间新面的信息
               mesh->Faces[idx_face]->Verts[0]=mesh->Lines[volu->Lines[0]]->Child[2];
               mesh->Faces[idx_face]->Verts[1]=volu->Verts[2];
               mesh->Faces[idx_face]->Verts[2]=volu->Verts[3];
              
	       mesh->Faces[idx_face]->Old_Child[0]=-1;
               mesh->Faces[idx_face]->Old_Child[1]=-1;
               mesh->Faces[idx_face]->Child[0]=-1;
               mesh->Faces[idx_face]->Child[1]=-1;
               mesh->Faces[idx_face]->Child[2]=-1;

               mesh->Faces[idx_face]->ID_Boundary=-1;

	       mesh->Faces[idx_face]->Lines[0]=volu->Lines[5];
               mesh->Faces[idx_face]->Lines[1]=idx_line-1;
               mesh->Faces[idx_face++]->Lines[2]=mesh->Faces[volu->Faces[3]]->Child[2];

	       //更新两个单元的信息
               mesh->Volus[idx_volu]->Verts[0]=volu->Verts[1];
               mesh->Volus[idx_volu]->Verts[1]=volu->Verts[2];
               mesh->Volus[idx_volu]->Verts[2]=volu->Verts[3];
               mesh->Volus[idx_volu]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

               mesh->Volus[idx_volu]->Lines[0]=volu->Lines[3];
               mesh->Volus[idx_volu]->Lines[1]=volu->Lines[4];
               mesh->Volus[idx_volu]->Lines[2]=
	       volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[1]:mesh->Lines[volu->Lines[0]]->Child[0];
               mesh->Volus[idx_volu]->Lines[3]=volu->Lines[5];
               mesh->Volus[idx_volu]->Lines[5]=idx_line-1;
	       if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
               mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
               else
	      mesh->Volus[idx_volu]->Lines[4]=mesh->Faces[volu->Faces[3]]->Old_Child[1];

	       if(i==0)
   	       {
                mesh->Volus[idx_volu]->Father=j;
                mesh->Volus[j]->Father=j;
               }
               else
               mesh->Volus[idx_volu]->Father=mesh->Volus[j]->Father;
               mesh->Volus[idx_volu]->Ancestor=mesh->Volus[j]->Ancestor;

               mesh->Volus[idx_volu]->Type=0;

               mesh->Volus[idx_volu]->Faces[0]=idx_face-1;
	       if(mesh->Faces[volu->Faces[3]]->Old_Child[0]<0)
               mesh->Volus[idx_volu]->Faces[2]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Child[1]:mesh->Faces[volu->Faces[3]]->Child[0];
              else
	      mesh->Volus[idx_volu]->Faces[2]=
               volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Old_Child[0]:mesh->Faces[volu->Faces[3]]->Child[0];

	       mesh->Volus[idx_volu]->Faces[1]=idx_face-2;
               mesh->Volus[idx_volu++]->Faces[3]=volu->Faces[0];


	       mesh->Volus[j]->Verts[0]=volu->Verts[0];
               mesh->Volus[j]->Verts[1]=volu->Verts[2];
               mesh->Volus[j]->Verts[2]=volu->Verts[3];
               mesh->Volus[j]->Verts[3]=mesh->Lines[volu->Lines[0]]->Child[2];

               tmp_line= volu->Verts[0]==mesh->Lines[volu->Lines[0]]->Verts[0]?
	       mesh->Lines[volu->Lines[0]]->Child[0]:mesh->Lines[volu->Lines[0]]->Child[1];
	       mesh->Volus[j]->Lines[0]=volu->Lines[1];
               mesh->Volus[j]->Lines[1]=volu->Lines[2];
               mesh->Volus[j]->Lines[2]=tmp_line;
               mesh->Volus[j]->Lines[3]=volu->Lines[5];
	       if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
               mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Child[2];
	       else
               mesh->Volus[j]->Lines[4]=mesh->Faces[volu->Faces[3]]->Old_Child[1];

               mesh->Volus[j]->Lines[5]=idx_line-1;

	       tmp_face=volu->Faces[1];
               mesh->Volus[j]->Faces[0]=idx_face-1;
               mesh->Volus[j]->Faces[1]=volu->Faces[2];
	       if(mesh->Faces[volu->Faces[3]]->Old_Child[1]<0)
               mesh->Volus[j]->Faces[2]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Child[1];
	       else
	       mesh->Volus[j]->Faces[2]=
	       volu->Verts[0]==mesh->Faces[mesh->Faces[volu->Faces[3]]->Child[0]]->Verts[0]?
	       mesh->Faces[volu->Faces[3]]->Child[0]:mesh->Faces[volu->Faces[3]]->Old_Child[0];

               mesh->Volus[j]->Faces[3]=tmp_face;

               mesh->Volus[j]->Type=0;


	       mesh->Volus[j]->Child[0]=j;
	       mesh->Volus[j]->Child[1]=idx_volu-1;


	       //ReConstruct(mesh->Volus[idx_volu-1]);
               //ReConstruct(mesh->Volus[idx_volu-2]);
           
	   if(MarkJudge(mesh,mesh->Volus[j])<0)
	   {
	     mesh->Volus[j]->Mark=-1;
	   }
           if(MarkJudge(mesh,mesh->Volus[idx_volu-1])>=0) 
	   {
             mesh->Volus[idx_volu-1]->Mark=1;
	   }
           else
	   mesh->Volus[idx_volu-1]->Mark=-1;


        }//4
  
       

       }//type2

   }//单元遍历
 Iter_volu=idx_volu;
 }//加密三次循环
 mesh->Num_Verts_Global=total_vert;
 mesh->Num_Lines_Global=total_line;
 mesh->Num_Faces_Global=total_face;
 mesh->Num_Volus_Global=total_volu;
   
}//MeshRefineBisection结束
int
MeshMarkElemNum(MESH *mesh, double *eta, double *theta)
{
int i,j;
int *ix=malloc(mesh->Num_Volus_Global*sizeof(int));
double curr_error=0.0,total_error=0.0;
for(i=0;i<mesh->Num_Volus_Global;++i)
 ix[i]=i;
QuickSort(eta,0,mesh->Num_Volus_Global-1,sizeof(double),ix,cmp);//按照eta的大小顺序调整ix的顺序
for(i=0;i<mesh->Num_Volus_Global;++i)
 total_error+=eta[i];
for(i=0;i<mesh->Num_Volus_Global;++i)
{
 curr_error+=eta[ix[i]];
 if(curr_error>=*theta*total_error)
    break;
}
i++;
free(ix);
return i;
}

void
MeshMarkElem(MESH *mesh, int *M, double *eta, double *theta,int *num)
{
int i,j;
int *ix=malloc(mesh->Num_Volus_Global*sizeof(int));
double curr_error=0.0,total_error=0.0;
for(i=0;i<mesh->Num_Volus_Global;++i)
 ix[i]=i;
QuickSort(eta,0,mesh->Num_Volus_Global-1,sizeof(double),ix,cmp);//按照eta的大小顺序调整ix的顺序
for(j=0;j<*num;++j)
M[j]=ix[j];
free(ix);
}


//计算单元的体积
double 
GetVolume(MESH *Mesh,VOLU *volu)
{
 double volume;
 MESH *mesh;
 mesh=Mesh;
 double ax=mesh->Verts[volu->Verts[0]]->Coord[0]-mesh->Verts[volu->Verts[1]]->Coord[0];
 double ay=mesh->Verts[volu->Verts[0]]->Coord[1]-mesh->Verts[volu->Verts[1]]->Coord[1];
 double az=mesh->Verts[volu->Verts[0]]->Coord[2]-mesh->Verts[volu->Verts[1]]->Coord[2];
 double bx=mesh->Verts[volu->Verts[1]]->Coord[0]-mesh->Verts[volu->Verts[2]]->Coord[0];
 double by=mesh->Verts[volu->Verts[1]]->Coord[1]-mesh->Verts[volu->Verts[2]]->Coord[1];
 double bz=mesh->Verts[volu->Verts[1]]->Coord[2]-mesh->Verts[volu->Verts[2]]->Coord[2];
 double cx=mesh->Verts[volu->Verts[1]]->Coord[0]-mesh->Verts[volu->Verts[3]]->Coord[0];
 double cy=mesh->Verts[volu->Verts[1]]->Coord[1]-mesh->Verts[volu->Verts[3]]->Coord[1];
 double cz=mesh->Verts[volu->Verts[1]]->Coord[2]-mesh->Verts[volu->Verts[3]]->Coord[2];
 volume=cx*(ay*bz-az*by)+cy*(az*bx-ax*bz)+cz*(ax*by-ay*bx);
 volume=abs(volume/6);
 return volume;
}

//求jacobi变换矩阵
void
GetJacobiMatrix(MESH *Mesh,VOLU *volu, double **B) //double b[3])
{

   printf ( "11111\n" );
 MESH *mesh;
 mesh=Mesh;
 printf ( "2222222\n" );
 double x0=mesh->Verts[volu->Verts[0]]->Coord[0];
 double y0=mesh->Verts[volu->Verts[0]]->Coord[1];
 double z0=mesh->Verts[volu->Verts[0]]->Coord[2];
 double x1=mesh->Verts[volu->Verts[1]]->Coord[0];
 double y1=mesh->Verts[volu->Verts[1]]->Coord[1];
 double z1=mesh->Verts[volu->Verts[1]]->Coord[2];
 double x2=mesh->Verts[volu->Verts[2]]->Coord[0];
 double y2=mesh->Verts[volu->Verts[2]]->Coord[1];
 double z2=mesh->Verts[volu->Verts[2]]->Coord[2];
 double x3=mesh->Verts[volu->Verts[3]]->Coord[0];
 double y3=mesh->Verts[volu->Verts[3]]->Coord[1];
 double z3=mesh->Verts[volu->Verts[3]]->Coord[2];
 printf ( "3333333333\n" );
 B[0][0]=x1-x0; 
 B[0][1]=x2-x0; 
 B[0][2]=x3-x0; 
 B[1][0]=y1-y0; 
 B[1][1]=y2-y0; 
 B[1][2]=y3-y0; 
 B[2][0]=z1-z0; 
 B[2][1]=z2-z0; 
 B[2][2]=z3-z0; 
 printf ( "444444444\n" );
 //b[0]=x0;
 //b[1]=y0;
 //b[2]=z0;
   
}

//得到矩阵的逆
void
GetInverseMatrix(double A[3][3],double IA[3][3])
{
  double a11=A[0][0];
  double a12=A[0][1];
  double a13=A[0][2];
  double a21=A[1][0];
  double a22=A[1][1];
  double a23=A[1][2];
  double a31=A[2][0];
  double a32=A[2][1];
  double a33=A[2][2];
  double B=(a22*a33-a23*a32)*a11+a31*a12*a23-a31*a13*a22-a21*a12*a33+a21*a13*a32;
  IA[0][0]=  (a22*a33-a23*a32)/B;
  IA[0][1]= -(a12*a33-a13*a32)/B;
  IA[0][2]=  (a12*a23-a13*a22)/B;
  IA[1][0]= -(a21*a33-a23*a31)/B;
  IA[1][1]=  (a11*a33-a13*a31)/B;
  IA[1][2]= -(a11*a23-a13*a21)/B;
  IA[2][0]=  (a21*a32-a22*a31)/B;
  IA[2][1]= -(a11*a32-a12*a31)/B;
  IA[2][2]=  (a11*a22-a12*a21)/B;
}


/**从网格最终获得一个单元，用来进行有限元空间等的操作 */
void GetElement3D(MESH *mesh,int volu_num, ELEMENT3D *element3D)
{
  element3D->ID_Num = volu_num;
  element3D->Num_Verts = 4;
  int i;
  i = mesh->Volus[volu_num]->Verts[0];
  element3D->Vert_X[0] = mesh->Verts[i]->Coord[0];
  element3D->Vert_Y[0] = mesh->Verts[i]->Coord[1];
  element3D->Vert_Z[0] = mesh->Verts[i]->Coord[2];
  i = mesh->Volus[volu_num]->Verts[1];
  element3D->Vert_X[1] = mesh->Verts[i]->Coord[0];
  element3D->Vert_Z[1] = mesh->Verts[i]->Coord[2];
  element3D->Vert_Y[1] = mesh->Verts[i]->Coord[1];
  i = mesh->Volus[volu_num]->Verts[2];
  element3D->Vert_X[2] = mesh->Verts[i]->Coord[0];
  element3D->Vert_Y[2] = mesh->Verts[i]->Coord[1];  
  element3D->Vert_Z[2] = mesh->Verts[i]->Coord[2];
  i = mesh->Volus[volu_num]->Verts[3];
  element3D->Vert_X[3] = mesh->Verts[i]->Coord[0];
  element3D->Vert_Y[3] = mesh->Verts[i]->Coord[1];  
  element3D->Vert_Z[3] = mesh->Verts[i]->Coord[2];

  element3D->Volu = GetVolume(mesh,mesh->Volus[volu_num]);
  GetJacobiMatrix(mesh,mesh->Volus[volu_num],element3D->Jacobian); 
  GetInverseMatrix(element3D->Jacobian,element3D->Inv_Jacobian);
}


void InitialElem3D(MESH *mesh, ELEMENT3D *elem3D)
{ 
  int i,Num_Verts;
  Num_Verts = 4;
  elem3D->Vert_X = malloc(Num_Verts*sizeof(double));
  elem3D->Vert_Y = malloc(Num_Verts*sizeof(double));
  elem3D->Vert_Z = malloc(Num_Verts*sizeof(double));
  elem3D->Jacobian = malloc(3*sizeof(double*));
  for(i=0;i<3;i++)
    elem3D->Jacobian[i] = malloc(3*sizeof(double));
  elem3D->Inv_Jacobian = malloc(3*sizeof(double*));
  for(i=0;i<3;i++)
    elem3D->Inv_Jacobian[i] = malloc(3*sizeof(double));
}

void FreeElem3D(ELEMENT3D *elem3D)
{
    free(elem3D->Vert_X);
    free(elem3D->Vert_Y);
    free(elem3D->Vert_Z);
    int i;
    for(i=0;i<3;i++)
    {
        free(elem3D->Inv_Jacobian[i]);
	free(elem3D->Jacobian[i]);
    }
    free(elem3D->Inv_Jacobian);
    free(elem3D->Jacobian);
    
    free(elem3D);
}



void GetElementCoord(ELEMENT3D *elem3D,double Quad_xi,double Quad_eta, double Quad_zeta,
                     double *Quad_x, double *Quad_y,double *Quad_z)
{
   // x-coordination
    Quad_x[0] = (1-Quad_xi-Quad_eta-Quad_zeta)*elem3D->Vert_X[0] + Quad_xi*elem3D->Vert_X[1] +
            Quad_eta*elem3D->Vert_X[2]+Quad_zeta*elem3D->Vert_X[3];
    //y-coordination
    Quad_y[0] = (1-Quad_xi-Quad_eta-Quad_zeta)*elem3D->Vert_Y[0] + Quad_xi*elem3D->Vert_Y[1] +
            Quad_eta*elem3D->Vert_Y[2]+Quad_zeta*elem3D->Vert_Y[3];
   //y-coordination
    Quad_z[0] = (1-Quad_xi-Quad_eta-Quad_zeta)*elem3D->Vert_Z[0] + Quad_xi*elem3D->Vert_Z[1] +
            Quad_eta*elem3D->Vert_Z[2]+Quad_zeta*elem3D->Vert_Z[3];
}

void FreeMesh(MESH *Mesh)
{
  printf("delete the Mesh: Verts, Lines, Faces!\n");
  
  int i;  
  for(i=0;i<Mesh->Num_Verts_Global;i++)  
    FreeVert(Mesh->Verts[i]);  
  free(Mesh->Verts);  
 
  for(i=0;i<Mesh->Num_Lines_Global;i++)
    FreeLine(Mesh->Lines[i]);
  free(Mesh->Lines);
  
  for(i=0;i<Mesh->Num_Faces_Global;i++)
    FreeFace(Mesh->Faces[i]);
  free(Mesh->Faces);  
  for(i=0;i<Mesh->Num_Volus_Global;i++)
    FreeVolu(Mesh->Volus[i]);
  free(Mesh->Volus);  
 
  free(Mesh);
}
void FreeVolu(VOLU *Volu)
{
  free(Volu);
}
void FreeFace(FACEE *Face)
{
   free(Face->Volus_Owned);
   free(Face);
}

void FreeLine(LINE *Line)
{
   free(Line->Faces_Owned);
   free(Line->Volus_Owned);
   free(Line);
}

void FreeVert(VERT *Vert)
{
   free(Vert->Lines_Owned);
   free(Vert->Faces_Owned);
   free(Vert->Volus_Owned);
   free(Vert);
}
